[home](README.md)

# 区間最小区間代入遅延セグ木

```cpp
class lst{
    public :

    const int inf = 1e9;
    vector<int> seg,lazy;
    int siz = 1;
    vector<bool> d;
    lst(int n,int x){
        while(siz < n){
            siz *= 2;
        }
        seg.assign(siz*2,x);
        lazy.assign(siz*2,0);
        d.assign(siz*2,false);
    }
    void push(int pos){
        if(!d[pos])return;
        seg[pos] = lazy[pos];
        d[pos] = false;
        if(pos < siz){
            lazy[pos*2] = seg[pos];
            lazy[pos*2+1] = seg[pos];
            d[pos*2] = true;
            d[pos*2+1] = true;
        }
    }
    void range_assign(int l,int r,int x){
        range_assign(l,r,x,1,0,siz);
    }
    int range_min(int l,int r){
        return range_min(l,r,1,0,siz);
    }
    private :
    void range_assign(int l,int r,int x,int pos,int a,int b){
        push(pos);
        if (r <= a || b <= l) return;
        if(l <= a && b <= r){
            seg[pos] = x;
            lazy[pos] = x;
            d[pos] = true;
            return;
        }

        int mid = (a+b)/2;
        range_assign(l,r,x,pos*2,a,mid);
        range_assign(l,r,x,pos*2+1,mid,b);
        seg[pos] = min(seg[pos*2],seg[pos*2+1]);
    }
    int range_min(int l,int r,int pos,int a,int b){
        push(pos);
        if(r <= a || b <= l) return -inf;
        if(l <= a && b <= r){
            return seg[pos];
        }
        int mid = (a+b)/2;
        return min(
            range_min(l,r,pos*2,a,mid),
            range_min(l,r,pos*2+1,mid,b)
        );
    }
};

```
