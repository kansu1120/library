[
  {
    "title": "N進数変換",
    "url": "N進数変換.html",
    "content": "# N進数変換  ## 10進数の時はintを使い他のときはstringを使っている   # 10 -> N f(n,N)　で任意の10進数n をN進数に変換できる  ```cpp  string f(int n,int N){     string ans = \"\";     while (n) {         ans.push_back('0' + n % N);         n /= N;     }     reverse(ans.begin(),ans.end());     return ans; } ```   # N -> 10  f(s,n) で任意のn進数(n < 10)を10進数に変換できる  ```cpp int f(string s, int n){     int v = 0;     for(char c : s){         v = v * N + (c - '0');     }     return v; } ```  # X -> y  ```cpp   // 先頭の 0 を削除 void trim(vector<int>& a){     while(a.size() > 1 && a[0] == 0) a.erase(a.begin()); }  // a（x進数）を y で割る // 商を a に格納し、余りを返す int div_mod(vector<int>& a, int x, int y){     vector<int> q;     int cur = 0;     for(int d : a){         cur = cur * x + d;         q.push_back(cur / y);         cur %= y;     }     a = q;     trim(a);     return cur; }  // x進数(string) → y進数(string) string f(string s, int x, int y){     vector<int> a;     for(char c : s) a.push_back(c - '0');     trim(a);      if(a.size() == 1 && a[0] == 0) return \"0\";      string res;     while(!(a.size() == 1 && a[0] == 0)){         int r = div_mod(a, x, y);         res.push_back(char('0' + r));     }     reverse(res.begin(), res.end());     return res; } ```    "
  },
  {
    "title": "RLE",
    "url": "RLE.html",
    "content": "# ラングレス圧縮  string を入力  int char の　pair の vector でリターン  aaab ->  { 3 , a } , { 1 , b }  ```cpp vector<pair<int,char>> r(string s){     vector<pair<int,char>> ans;     for(int i = 0;i < s.size();i++){         if(ans.size()==0 || ans[ans.size()-1].second != s[i]){             ans.push_back({1,s[i]});         }         else{             ans[ans.size()-1].first++;         }     }      return ans; } ``` "
  },
  {
    "title": "RMaxQ",
    "url": "RMaxQ.html",
    "content": "# RMaxQ segmenttree 名前(サイズ)　で定義  名前.update( i , x ) で i 番目の要素を x に変更  名前.query( l , r ) で l から r の範囲内の最大値を取得  ```cpp  class segmenttree{ public:     long long INF = 1e18;     long long siz = 1;     vector<long long> v;     segmenttree (long long n){         siz = 1;         while(siz < n)siz *= 2;         v.assign(2*siz,-INF);     }     void update(long long i, long long x){         i += siz;         v[i] = x;         while(i > 1){             i /= 2;             v[i] = max(v[i*2],v[i*2+1]);         }     }      long long query(int l,int r){         return query(l,r,1,0,siz-1);     }     private :      long long query(int L,int R,int s,int l,int r){         long long ans = -INF;         if(r < L || l > R)return -INF;         if(l >= L && r <= R){             return v[s];         }         ans = max(ans,query(L,R,s*2,l,(l+r)/2));         ans = max(ans,query(L,R,s*2+1,(l+r)/2+1,r));         return ans;     } };  ```  "
  },
  {
    "title": "RMinQ",
    "url": "RMinQ.html",
    "content": "# RMinQ  segmenttree 名前(サイズ)　で定義  名前.update( i , x ) で i 番目の要素を x に変更  名前.query( l , r ) で l から r の範囲内の最大値を取得   ```cpp class segmenttree{ public:     long long INF = 1e18;     long long siz = 1;     vector<long long> v;     segmenttree (long long n){         siz = 1;         while(siz < n)siz *= 2;         v.assign(2*siz,INF);     }     void update(long long i, long long x){         i += siz;         v[i] = x;         while(i > 1){             i /= 2;             v[i] = min(v[i*2],v[i*2+1]);         }     }      long long query(int l,int r){         return query(l,r,1,0,siz-1);     }     private :      long long query(int L,int R,int s,int l,int r){         long long ans = INF;         if(l >= L && r <= R){             ans = min(ans,v[s]);             return ans;         }         if(r < L || l > R)return INF;         ans = min(ans,query(L,R,s*2,l,(l+r)/2));         ans = min(ans,query(L,R,s*2+1,(l+r)/2+1,r));         return ans;     } };  ``` "
  },
  {
    "title": "RSQ",
    "url": "RSQ.html",
    "content": "# 区間和のセグ木   segmenttree 名前(サイズ)　で定義   名前.update( i , x ) で i 番目の要素を x に変更   名前.query( l , r ) で l から r の範囲内の合計値を取得   ```cpp class segmenttree{ public:     long long siz = 1;     vector<long long> v;     segmenttree (long long n){         siz = 1;         while(siz < n)siz *= 2;         v.assign(2*siz,0);     }     void update(long long i, long long x){         i += siz;         v[i] = x;         while(i > 1){             i /= 2;             v[i] = v[i*2]+v[i*2+1];         }     }      long long query(int l,int r){         return query(l,r,1,0,siz-1);     }     private :      long long query(int L,int R,int s,int l,int r){         long long ans = 0;         if(l >= L && r <= R){             ans += v[s];             return ans;         }         if(r < L || l > R)return 0;         ans += query(L,R,s*2,l,(l+r)/2);         ans += query(L,R,s*2+1,(l+r)/2+1,r);         return ans;     } };  ``` "
  },
  {
    "title": "countmultiset",
    "url": "countmultiset.html",
    "content": "# countが高速に行えるmaltiset  使い方はmulsisetと同じ  countがlogNで実行できる  ```cpp template<typename T> class countable_multiset{     public :     multiset<T> ms;     map<T,int> cnt;     void insert(const T& n){         cnt[n]++;         ms.insert(n);     }     void all_erase(const T& n){         cnt.erase(n);         ms.erase(n);     }     void it_erase(const T& n){         auto it = ms.find(n);         if(it==ms.end())return;         cnt[n] = max(0,cnt[n]-1);         if(cnt[n]==0)cnt.erase(n);         ms.erase(it);     }     int count(const T& n){         if(cnt.count(n))return cnt[n];         return 0;     }     auto find(const T& n){         return ms.find(n);     } }; ``` "
  },
  {
    "title": "imos",
    "url": "imos.html",
    "content": "# imos法のライブラリ  plus(l,r,x) でl~rまでにxを加算する  solve() をしたら完成  そこからは普通のvecotrと同じようにアクセスできる  ```cpp  class imos{     public :      vector<long long> v;     long long n;     imos(long long x){         v.assign(x,0);         n = v.size();     }     void plus(long long l,long long r,long long x){         v[l] += x;         if(r != n-1)v[r+1]-=x;     }     void solve(){         for(long long i = 1;i < n;i++){             v[i] += v[i-1];         }     }     long long at(long long pos){         return v[pos];     }     long long operator[](long long pos) const {         return v[pos];     } };  ``` "
  },
  {
    "title": "imos2D",
    "url": "imos2D.html",
    "content": "# imos2D  ``` (a,b)(   )(   ) (   )(   )(   ) (   )(   )(c,d)   ``` update(a,b,c,d,x)でここの範囲に+xできる  build()をやったらOK   ```cpp  class imos2D{     public :     vector<vector<long long>> v;     long long h,w;     imos2D(long long H,long long W){         h = H;         w = W;         v.assign(h,vector<long long>(w));     }     void update(long long a,long long b,long long c,long long d,long long x){         v[a][b]+=x;         if(c+1 < h)v[c+1][b]-=x;         if(d+1 < w)v[a][d+1]-=x;         if(c+1 < h && d+1 < w)v[c+1][d+1]+=x;     }     void build(){         for(long long i = 0;i < h;i++){             for(long long j = 1;j < w;j++){                 v[i][j] += v[i][j-1];             }         }         for(long long j = 0;j < w;j++){             for(long long i = 1;i < h;i++){                 v[i][j] += v[i-1][j];             }         }     }     vector<long long>& operator[](long long i){         return v[i];     }     const vector<long long>& operator[](long long i) const{         return v[i];     } };  ``` "
  },
  {
    "title": "index",
    "url": "index.html",
    "content": " - [一覧](一覧.md)  - [template](template.md)    - [累積和](累積和まとめ.md)    - [数学](数学まとめ.md)    - [グラフ](グラフまとめ.md)    - [データ構造](データ構造.md)  - [二分探索](二分探索.md)  - [その他典型](その他典型.md)           "
  },
  {
    "title": "order_statistic_tree",
    "url": "order_statistic_tree.html",
    "content": "# order_statistic_tree  insert,erase,find,cnt,order,lower_bound,upper_bound,miman,ika  が可能  ```cpp   class trp{     const long long INF = 1e18;     struct node{         int key;         int priority;         int siz;         node* left;         node* right;         node(int k,int p){             key = k;             priority = p;             siz = 1;             left = nullptr;             right = nullptr;         }     };      node* root;       bool find(node* t,int x){         if(t == nullptr)return false;         if(t -> key == x)return true;         if(x < t->key)return find(t->left,x);         else return find(t->right,x);     }     node* merge(node* l,node* r){         if(l == nullptr)return r;         if(r == nullptr)return l;         if(l->priority > r->priority){             l-> right = merge(l->right,r);             update(l);             return l;         }         else{             r->left = merge(l,r->left);             update(r);             return r;         }     }     pair<node*,node*> split(node* t,int x){         if(t==nullptr)return {nullptr,nullptr};         if(x <= t->key){             pair<node*,node*> p = split(t->left,x);             t -> left = p.second;             update(t);             return {p.first,t};         }         else{             pair<node*,node*> p = split(t->right,x);             t -> right = p.first;             update(t);             return {t,p.second};                     }     }     int size(node* t){         if(t == nullptr)return 0;         else return t -> siz;     }     void update(node* t){         if(t == nullptr)return;         t -> siz = 1 + size(t->left)+size(t->right);     }     int cnt(node* t,int k){         if(t == nullptr)return -INF;         int lsiz = size(t->left);         if(lsiz > k){             return cnt(t -> left,k);         }         else if(k==lsiz){             return t->key;         }         else{             return cnt(t -> right,k - lsiz - 1);         }     }     int order(node* t,int x){         if(t == nullptr)return 0;         if(x <= t->key){             return order(t -> left,x);         }         else{             return size(t -> left) + 1 + order(t->right,x);         }     }     node* lower_bound(node* t, int x){         if(t == nullptr) return nullptr;          if(t->key < x){             return lower_bound(t->right, x);         }         else{             node* res = lower_bound(t->left, x);             if(res != nullptr) return res;             else return t;         }     }     node* upper_bound(node* t, int x){         if(t == nullptr) return nullptr;          if(t->key <= x){             return upper_bound(t->right, x);         }         else{             node* res = upper_bound(t->left, x);             if(res != nullptr) return res;             else return t;         }     }     node* ika(node* t,int x){         if(t==nullptr)return nullptr;         if(t -> key > x){             return ika(t->left,x);         }         else{             node*res = ika(t->right,x);             if(res != nullptr)return res;             else return t;         }     }       public :      trp(){         root = nullptr;     }     bool find(int x){         return find(root,x);     }     void insert(int x){         if(find(x))return;         pair<node*,node*> p = split(root,x);         node* r = p.second;         node* l = p.first;         node* n = new node(x,rand());         root = merge(merge(l,n),r);     }     void erase(int x){         if(!find(x))return ;         pair<node*,node*> a = split(root,x);         pair<node*,node*> b = split(a.second,x+1);         root = merge(a.first,b.second);     }     int cnt(int k){         return  cnt(root,k);     }     int order(int x){         return order(root,x);     }     int lower_bound(int x){         node* res = lower_bound(root, x);         if(res == nullptr) return -INF;         return res->key;     }     int upper_bound(int x){         node* res = upper_bound(root, x);         if(res == nullptr) return -INF;         return res->key;     }     int miman(int x){         int k = order(x) -1;         if(k < 0)return -INF;         return cnt(k);     }     int ika(int x){         node* k = ika(root,x);         if(k == nullptr)return -INF;         else return k->key;     } };  ``` "
  },
  {
    "title": "rmax",
    "url": "rmax.html",
    "content": "# 循環配列での長さwの区間の和の最大値  循環させる前の配列と長さWを入れる   ```cpp      long long rmax(vector<int> v,long long w){         int n = v.size();         rep(i,n)v.push_back(v[i]);         n *= 2;         if(w >= n/2){             long long ans = 0;             rep(i,n/2)ans += v[i];             return ans;         }         long long sum = 0;         rep(i,w)sum += v[i];         long long ans = sum;         for(long long i = 0;i < n/2-1;i++){             sum -= v[i];             sum += v[i+w];             ans = max(ans,sum);         }         return ans;     }  ``` "
  },
  {
    "title": "rmin",
    "url": "rmin.html",
    "content": "# 循環配列での長さwの区間の和の最小値  循環させる前の配列と長さWを入れる   ```cpp      long long rmax(vector<int> v,long long w){         int n = v.size();         rep(i,n)v.push_back(v[i]);         n *= 2;         if(w >= n/2){             long long ans = 0;             rep(i,n/2)ans += v[i];             return ans;         }         long long sum = 0;         rep(i,w)sum += v[i];         long long ans = sum;         for(long long i = 0;i < n/2-1;i++){             sum -= v[i];             sum += v[i+w];             ans = min(ans,sum);         }         return ans;     }  ``` "
  },
  {
    "title": "string部分一致",
    "url": "string部分一致.html",
    "content": "# string部分一致確認   ```cpp  bool same(string& s,string& t,int x){     // sのx文字目からがtと一致するならtrue     int j = 0;     for(int i = x;i < x+t.size();i++){         if(i >= s.size())return false;         if(j >= t.size())return false;         if(s[i]!=t[j]){             return false;         }         j++;     }     return true; }  ``` "
  },
  {
    "title": "template",
    "url": "template.html",
    "content": "--- layout: default ---  # よく使うやつ       ```cpp #include <bits/stdc++.h> #include <atcoder/all> using namespace atcoder; using namespace std; using ll = long long; #define rep(i , n) for(int i=0; i< (int)(n); i++) #define int long long const ll INF = 1e18; const int inf = 1e9; const int mod = 998244353; template<class T> void chmin(T& a, T b){ if(a > b) a = b; } template<class T> void chmax(T& a, T b){ if(a < b) a = b; } void yes(){cout << \"Yes\" << endl;} void no(){cout << \"No\" << endl;} int32_t main(){     ios::sync_with_stdio(false);     cin.tie(nullptr);      }   ``` "
  },
  {
    "title": "treap木",
    "url": "treap木.html",
    "content": "# treap木  insert  find  erase   ができる   ```cpp  class trp{     struct node{         int key;         int priority;         node* left;         node* right;         node(int k,int p){             key = k;             priority = p;             left = nullptr;             right = nullptr;         }     };      node* root;       bool find(node* t,int x){         if(t == nullptr)return false;         if(t -> key == x)return true;         if(x < t->key)return find(t->left,x);         else return find(t->right,x);     }     node* merge(node* l,node* r){         if(l == nullptr)return r;         if(r == nullptr)return l;         if(l->priority > r->priority){             l-> right = merge(l->right,r);             return l;         }         else{             r->left = merge(l,r->left);             return r;         }     }     pair<node*,node*> split(node* t,int x){         if(t==nullptr)return {nullptr,nullptr};         if(x <= t->key){             pair<node*,node*> p = split(t->left,x);             t -> left = p.second;             return {p.first,t};         }         else{             pair<node*,node*> p = split(t->right,x);             t -> right = p.first;             return {t,p.second};                     }     }      public :      trp(){         root = nullptr;     }     bool find(int x){         return find(root,x);     }     void insert(int x){         if(find(x))return;         pair<node*,node*> p = split(root,x);         node* r = p.second;         node* l = p.first;         node* n = new node(x,rand());         root = merge(merge(l,n),r);     }     void erase(int x){         if(!find(x))return ;         pair<node*,node*> a = split(root,x);         pair<node*,node*> b = split(a.second,x+1);         root = merge(a.first,b.second);     } };  ``` "
  },
  {
    "title": "unionfind",
    "url": "unionfind.html",
    "content": "# union find   find：根を求める connect：繋げる(もともと繋がってたらfalseをreturn) same：結合か判定 size：そのノードの連結要素数  ```cpp  class UnionFind { public: \t//@brief Union-Findのコンストラクタ \t//@param n ノード数 \tUnionFind(int n) : PoS(n, -1) {}  \t//@brief 根を求める \t//@param x ノード番号 \t//@return xの根のノード番号 \tint find(int x) { \t\tif (PoS[x] < 0) { \t\t\treturn x; \t\t} \t\treturn (PoS[x] = find(PoS[x])); \t}  \t//@brief 接続かを判定する \t//@param x ノード1 \t//@param y ノード2 \tbool same(int x, int y) { \t\treturn (find(x) == find(y)); \t}  \t//@brief 連結要素数を数える \t//@param x ノード番号 \t//@return xの連結要素数 \tint size(int x) { \t\treturn -PoS[find(x)]; \t}  \t//@brief 集合を繋げる \t//@param x ノード1 \t//@param y ノード2 \t//@return 結合が行えたか(既に結合していた:false) \tbool connect(int x, int y) { \t\tx = find(x); \t\ty = find(y); \t\tif (x == y) return false;  \t\tif (-PoS[x] < -PoS[y]) { \t\t\tstd::swap(x, y); \t\t} \t\tPoS[x] += PoS[y]; \t\tPoS[y] = x; \t\treturn true; \t} private: \t//@brief 親もしくは要素数(Parent or Size) \tstd::vector<int> PoS; };  ``` "
  },
  {
    "title": "xorセグ木",
    "url": "xorセグ木.html",
    "content": "# xorのセグ木  segmenttree seg(n)  サイズnで定義  seg.update(i,x) i番目をxにする  seg.query(l,r) l~rの区間のxorを出す  ```cpp  class segmenttree{ public:     long long INF = 1e18;     long long siz = 1;     vector<long long> v;     segmenttree (long long n){         siz = 1;         while(siz < n)siz *= 2;         v.assign(2*siz,0);     }     void update(long long i, long long x){         i += siz;         v[i] = x;         while(i > 1){             i /= 2;             v[i] = v[i*2]^v[i*2+1];         }     }      long long query(int l,int r){         return query(l,r,1,0,siz-1);     }     private :      long long query(int L,int R,int s,int l,int r){         long long ans = 0;         if(l >= L && r <= R){             ans = ans^v[s];             return ans;         }         if(r < L || l > R)return 0;         ans ^= query(L,R,s*2,l,(l+r)/2);         ans ^= query(L,R,s*2+1,(l+r)/2+1,r);         return ans;     } };  ``` "
  },
  {
    "title": "その他典型",
    "url": "その他典型.html",
    "content": "# その他典型 - [ナップザック](ナップザック.md) - [ラングレス圧縮](RLE.md) - [座標圧縮](座標圧縮.md) - [最長増加部分列](最長増加部分列.md) - [便利なやつ](便利なやつ.md) - [ダブリング](ダブリング.md) "
  },
  {
    "title": "エラトステネスの篩",
    "url": "エラトステネスの篩.html",
    "content": "# エラトステネスの篩 p(n) = n 以下の素数を列挙してvector<int> でリターン  ```cpp vector<int> p(int n) {     vector<bool> ok(n+1,1);     ok[0] = ok[1] = 0;     for(int i = 2;i*i < n+1;i++){         if(ok[i]){             for(int j = i*i;j < n+1;j += i){                 ok[j] = 0;             }         }     }     vector<int> ans;     rep(i,n+1){         if(ok[i]){             ans.push_back(i);         }     }     return ans; } ``` "
  },
  {
    "title": "グラフまとめ",
    "url": "グラフまとめ.html",
    "content": "# グラフのあれこれ  - [強連結成分分解](強連結成分分解.md) - [木直径](木直径.md) - [フロー](フローまとめ.md) - [ワーシャルフロイド](ワーシャルフロイド.md) - [ダイクストラ](ダイクストラ.md) - [最小全域木](最小全域木.md) - [トポロジカルソート](トポロジカルソート.md) "
  },
  {
    "title": "セグ木まとめ",
    "url": "セグ木まとめ.html",
    "content": "# セグメント木  - [RmaxQ](RMaxQ.md) - [RminQ](RMinQ.md) - [RsumQ](RSQ.md) - [xorセグ木](xorセグ木.md) - [区間最大代入遅延セグ木](区間最大代入遅延セグ木.md) - [区間最小代入遅延セグ木](区間最小代入遅延セグ木.md) "
  },
  {
    "title": "ダイクストラ",
    "url": "ダイクストラ.html",
    "content": "# ダイクストラ  vector<vector<pair<int,int>>>の形のグラフを投入  v[i]にあるvector<pair<int,int>>をpとしたときpにはiからの{行き先、距離}を記録する  ds(グラフ,スタート地点)  スタート視点からの距離が記録されたvectorが帰ってくる  負の重みを持つ辺を入れてはいけない   ```cpp   vector<long long> ds(vector<vector<pair<long long,long long>>>& v,long long str){     long long inf = 1e9;     vector<long long> ans(v.size(),inf);     ans[str] = 0;     priority_queue<pair<long long,long long>,vector<pair<long long,long long>>,greater<pair<long long,long long>>> q;     q.push({0,str});     while(q.size()!=0){         long long cos = q.top().first;         long long pos = q.top().second;         q.pop();         if(cos > ans[pos])continue;         for(pair<long long,long long> i : v[pos]){             if(ans[i.first] > cos + i.second){                 ans[i.first] = cos + i.second;                 q.push({cos+i.second,i.first});             }         }     }     return ans; }  ``` "
  },
  {
    "title": "ダブリング",
    "url": "ダブリング.html",
    "content": "# ダブリング  dub(vector<int>) で宣言する  引数のvectorはそれぞれの場所について次の日に行く場所を記録  query(x,y)で今xにいる時y日後の場所がわかる  ```cpp  class dub{     public:      vector<vector<int>> d;     int n;     dub(vector<int>& a){          // 今の場所 i 　         // 次の日 a[i]　         // のvectorを入れる          n = a.size();         d.assign(n,vector<int>(64));         rep(i,n){             d[i][0] = a[i];         }         for(int j = 1;j < 64;j++){             for(int i = 0;i < n;i++){                 d[i][j] = d[d[i][j-1]][j-1];             }         }             }     int query(int x,int y){         //  今xにいる時y日後にいるところ         bitset<64> b(y);         int now = x;         rep(i,64){             if(b.test(i)){                 now = d[now][i];             }         }            return now;          } };  ``` "
  },
  {
    "title": "データ構造",
    "url": "データ構造.html",
    "content": "# たまに使えるかもしれないデータ構造  - [二分探索用vector](二分探索用vector.md) - [countmultiset](countmultiset.md) - [treap木](treap木.md) - [order_statistic_tree](order_statistic_tree.md) - [セグメント木](セグ木まとめ.md) - [imos](imos.md) - [imos2D](imos2D.md) - [union_find](unionfind.md) "
  },
  {
    "title": "トポロジカルソート",
    "url": "トポロジカルソート.html",
    "content": "# トポロジカルソート  vviのグラフを入れるとviの順番が返ってくる  ```cpp vector<int> tpr(vector<vector<int>> v){     int n = v.size();     vector<int>ans;     vector<int> cnt(n,0);     for(int i = 0;i < n;i++){         for(int j : v[i]){             cnt[j]++;         }     }     queue<int> q;     for(int i = 0;i < n;i++){         if(cnt[i]==0)q.push(i);     }     while(q.size()!=0){         int pos = q.front();         ans.push_back(pos);         q.pop();         for(int i : v[pos]){             cnt[i]--;             if(cnt[i]==0){                 q.push(i);             }         }     }     return ans; } ``` "
  },
  {
    "title": "ナップザック",
    "url": "ナップザック.html",
    "content": "# ナップザック  ```cpp int npz(vector<pair<int,int>> v,int w){     //{重さ、価値}、重さ制限     int n = v.size();     vector<vector<int>> dp(n,vector<int>(w+1,-1));     dp[0][0] = 0;     if(v[0].first <= w){         dp[0][v[0].first] = v[0].second;     }     for(int i = 0;i < n-1;i++){         for(int j = 0;j <= w;j++){             if(dp[i][j]==-1)continue;             if(j+v[i+1].first <= w){             dp[i+1][j+v[i+1].first] = max(dp[i+1][j+v[i+1].first],dp[i][j]+v[i+1].second);             }             dp[i+1][j] = max(dp[i+1][j],dp[i][j]);         }        }     int ans = -1;     for(int j = 0;j <= w;j++){         ans = max(ans,dp[n-1][j]);     }      return ans; } ``` "
  },
  {
    "title": "ナップザック復元",
    "url": "ナップザック復元.html",
    "content": "# ナップザック復元  ```cpp string npz_rev(vector<pair<long long,long long>> v,long long m){        // ( {重さ、価値} 、重さ制限 )      // 必要 = A     // どっちでも = B     // いらない = C      long long n = v.size();     vector<vector<long long>> dp(n,vector<long long>(m+1,-INF));     dp[0][0] = 0;     if(v[0].first <= m){         dp[0][v[0].first] = v[0].second;     }     for(long long i = 0;i < n-1;i++){         for(long long j = 0;j <= m;j++){             if(dp[i][j]==-INF)continue;             if(j+v[i+1].first <= m){             dp[i+1][j+v[i+1].first] = max(dp[i+1][j+v[i+1].first],dp[i][j]+v[i+1].second);             }             dp[i+1][j] = max(dp[i+1][j],dp[i][j]);         }        }     long long maxvalue = 0;     rep(i,m+1)maxvalue = max(maxvalue,dp[n-1][i]);     pair<bool,bool> sss = {false,false};     vector<pair<bool,bool>> ans(n,sss);      vector<vector<bool>> ok(n,vector<bool>(m+1,false));     for(long long i = 0;i <= m;i++){         if(dp[n-1][i]==maxvalue){             ok[n-1][i] = true;         }     }     vector<vector<long long>> cnt(n);     for(long long i = n-1;i > 0;i--){         for(long long j = 0;j <= m;j++){             if(!ok[i][j])continue;             if(dp[i-1][j]==dp[i][j]){                 ans[i].first = true;                 ok[i-1][j] = true;             }             if(j - v[i].first < 0)continue;             if(dp[i-1][j-v[i].first] + v[i].second == dp[i][j]){                 ans[i].second = true;                 ok[i-1][j-v[i].first] = true;             }         }     }     if(ok[0][0]==true){         ans[0].first = true;     }     if(v[0].first <= m &&  ok[0][v[0].first]){         ans[0].second = true;     }     string ret;     rep(i,n){         if(ans[i].first && ans[i].second){             ret += 'B';         }         else if(!ans[i].first && ans[i].second){             ret += 'A';         }         else{             ret += 'C';         }     }     return ret; } ``` "
  },
  {
    "title": "フローまとめ",
    "url": "フローまとめ.html",
    "content": "# フローのあれこれ  - [最大フロー](最大フロー.md)  - [二部マッチング](二部マッチング.md) "
  },
  {
    "title": "ライブラリ全文",
    "url": "ライブラリ全文.html",
    "content": "--- layout: default title: Kansu Library Full Dump (For AI) permalink: /ai-all/ ---  # Kansu C++ Library — Full Dump for AI  {% assign md_pages = site.pages   | where_exp: \"p\", \"p.path contains '.md'\"   | where_exp: \"p\", \"p.name != 'ai_all.md'\"   | sort: \"path\" %}  {% for p in md_pages %}  ---  ## {{ p.path }}  {{ p.content }}  {% endfor %} "
  },
  {
    "title": "ワーシャルフロイド",
    "url": "ワーシャルフロイド.html",
    "content": "# ワーシャルフロイド  vvpの形のグラフを入れる  wf(vvp) でvviに変換されて返ってくる   ```cpp  vector<vector<int>> wf(vector<vector<pair<int,int>>> v){     int n = v.size();     vector<vector<int>> dis(n);     for(int i = 0;i < n;i++){         vector<int> ans(n,inf);         ans[i] = 0;         priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;         q.push({0,i});         while(q.size()!=0){             int cos = q.top().first;             int pos = q.top().second;             q.pop();             if(ans[pos] < cos)continue;             for(pair<int,int> p : v[pos]){                 if(ans[p.first] > ans[pos]+p.second){                     ans[p.first] = ans[pos]+p.second;                     q.push({ans[pos]+p.second,p.first});                 }             }         }         dis[i] = ans;     }     return dis; }  ``` "
  },
  {
    "title": "一覧",
    "url": "一覧.html",
    "content": "   ---  ## 基本・テンプレ  - [templaaate](template.md) - [便利なやつ](便利なやつ.md)  ---  ## データ構造  - [データ構造まとめ](データ構造.md) - [セグ木まとめ](セグ木まとめ.md) - [RMaxQ](RMaxQ.md) - [RMinQ](RMinQ.md) - [RSQ（区間和）](RSQ.md) - [xorセグ木](xorセグ木.md) - [区間最大代入遅延セグ木](区間最大代入遅延セグ木.md) - [区間最小代入遅延セグ木](区間最小代入遅延セグ木.md) - [treap木](treap木.md) - [order statistic tree](order_statistic_tree.md) - [count が高速な multiset](countmultiset.md) - [中央値](中央値.md) - [union_find](unionfind.md) - [分数](分数.md)  ---  ## 累積和・imos  - [累積和](累積和.md) - [累積和まとめ](累積和まとめ.md) - [二次元累積和](二次元累積和.md) - [imos 法](imos.md) - [二次元 imos](imos2D.md)  ---  ## 二分探索・探索  - [二分探索](二分探索.md) - [二分探索用 vector](二分探索用vector.md) - [答えで二分探索](答えで二分探索.md) - [答えが広義短調増加になる答えでの二分探索](答えが広義短調増加になる問題の二分探索.md) - [答えが短調非減少になる答えでの二分探索](答えが短調非減少になる問題の二分探索.md) - [答えで lower_bound](答えでlower_bound.md) - [答えで upper_bound](答えでupper_bound.md)  ---  ## 文字列  - [RLE（ランレングス圧縮）](RLE.md) - [string 部分一致](string部分一致.md)  ---  ## 数学・数列  - [数学まとめ](数学まとめ.md) - [数列](数列.md) - [N進数変換](N進数変換.md) - [数字桁数](数字桁数.md) - [座標圧縮](座標圧縮.md) - [素数まとめ](素数まとめ.md) - [エラトステネスの篩](エラトステネスの篩.md) - [素因数分解 vi](素因数分解vi.md) - [素因数分解 pi](素因数分解pi.md) - [最長増加部分列](最長増加部分列.md) - [分数](分数.md) - [転倒数](転倒数.md)  ---  ## グラフ  - [グラフまとめ](グラフまとめ.md) - [強連結成分分解](強連結成分分解.md) - [木直径](木直径.md) - [ワーシャルフロイド](ワーシャルフロイド.md) - [ダイクストラ](ダイクストラ.md) - [最小全域木](最小全域木.md) - [トポロジカルソート](トポロジカルソート.md)  ---  ## フロー・マッチング  - [最大フロー](最大フロー.md) - [フローまとめ](フローまとめ.md) - [二部マッチング](二部マッチング.md) - [ダブリング](ダブリング.md) ---  ## DP・典型  - [ナップザック](ナップザック.md) - [ナップザック復元](ナップザック復元.md) - [最長増加部分列](最長増加部分列.md) - [その他典型](その他典型.md) - [ダブリング](ダブリング.md)  ## 編集、制作  - [ライブラリ全文](ライブラリ全文.md)   "
  },
  {
    "title": "中央値",
    "url": "中央値.html",
    "content": "# 中央値  chu(v) でvの中央値が求められる  中央値は小数になることもあることに注意  ```cpp  template<typename T>  double chu(vector<T> v){     int n = v.size();     sort(v.begin(),v.end());     if(n%2==0){         return (double)(v[n/2-1]+v[n/2])/(double)2;     }     else{         return (double)v[n/2];     } }  ``` "
  },
  {
    "title": "二分探索",
    "url": "二分探索.html",
    "content": "# 二分探索  - [boolの答えで二分探索](答えで二分探索.md) - [答えでlower_bound](答えでlower_bound.md) - [答えでupper_bound](答えでupper_bound.md) - [広義短調増加となる答えで特定の値の範囲を求める](答えが広義短調増加になる問題の二分探索.md) - [短調非増加となる答えで特定の値の範囲を求める](答えが短調非減少になる問題の二分探索.md) - [二分探索用vector](二分探索用vector.md) "
  },
  {
    "title": "二分探索用vector",
    "url": "二分探索用vector.html",
    "content": "# 二分探索用vector  使い方は普通のvectorと同じ  lb = lower_bound  up = upperbound  ika = 以下  mim = 未満  結果がイテレータではなく添字で帰ってくる  end() に相当するリターンは-1  X ~ Y　の間にある個数を数えたいときは ub(Y) - lb(X)  ```cpp  class bs{     public :      vector<long long> v;     bs(long long n,long long x){         v.assign(n,x);         return;     }     void sort(){         std::sort(v.begin(),v.end());     }     long long& at(long long pos){         return v[pos];     }     long long& operator[](long long pos){         return v[pos];     }     const long long& operator[](long long pos) const{         return v[pos];     }     void push_back(long long x){         v.push_back(x);     }     void pop_back(){         v.pop_back();     }     long long lb(long long x){         auto it = lower_bound(v.begin(),v.end(),x);         if(it == v.end()){             return -1;         }         else{             return it - v.begin();         }     }     long long ub(long long x){         auto it = upper_bound(v.begin(),v.end(),x);         if(it == v.end()){             return -1;         }         else{             return it - v.begin();         }     }     long long mim(long long x){         auto it = lower_bound(v.begin(),v.end(),x);         if(it == v.begin()){             return -1;         }         else{             --it;             return it - v.begin();         }     }     long long ika(long long x){         auto it = upper_bound(v.begin(),v.end(),x);         if(it == v.begin()){             return -1;         }         else{             --it;             return it - v.begin();         }            }     long long cnt_ika(long long x){         return ika(x)+1;     }     long long cnt_mim(long long x){         return mim(x)+1;     }     long long cnt_lb(long long x){         if(lb(x) == -1){             return 0;         }         return v.size() - lb(x);     }     long long cnt_ub(long long x){         if(ub(x)==-1){             return 0;         }         return v.size() - ub(x);     } };  ``` "
  },
  {
    "title": "二次元累積和",
    "url": "二次元累積和.html",
    "content": "# 二次元累積和  rui2D R(v) でvの二次元累積和を作る  R.query(a,b,c,d)で  ``` (a,b)(   )(   ) (   )(   )(   ) (   )(   )(c,d)   ``` の区間の累積を取る  ```cpp class rui2D{     public :      vector<vector<int>> v;     rui2D(vector<vector<int>>& a){         v = a;         int h = v.size();         int w = v[0].size();         for(int i = 0;i < h;i++){             for(int j = 1;j < w;j++){                 v[i][j] += v[i][j-1];             }         }         for(int j = 0;j < w;j++){             for(int i = 1;i < h;i++){                 v[i][j] += v[i-1][j];             }         }     }     int query(int a,int b,int c,int d){         int ans = v[c][d];         if(a!=0)ans -= v[a-1][d];         if(b!=0)ans -= v[c][b-1];         if(a!=0 && b != 0)ans += v[a-1][b-1];         return ans;     } }; ``` "
  },
  {
    "title": "二部マッチング",
    "url": "二部マッチング.html",
    "content": "# 二部マッチング   AIに書かせました また今度ちゃんと書きます  ```cpp class bipartite_matching{ public:     int nL,nR;     vector<vector<int>> g;     vector<int> dist;     vector<int> matchL,matchR;      bipartite_matching(int L,int R){         nL = L;         nR = R;         g.resize(nL);         matchL.assign(nL,-1);         matchR.assign(nR,-1);         dist.resize(nL);     }      void add_edge(int l,int r){         // l : 0..nL-1, r : 0..nR-1         g[l].push_back(r);     }      bool bfs(){         queue<int> q;         for(int i = 0;i < nL;i++){             if(matchL[i] == -1){                 dist[i] = 0;                 q.push(i);             }             else{                 dist[i] = -1;             }         }          bool reachable = false;          while(!q.empty()){             int v = q.front();             q.pop();             for(int to : g[v]){                 int u = matchR[to];                 if(u >= 0){                     if(dist[u] < 0){                         dist[u] = dist[v] + 1;                         q.push(u);                     }                 }                 else{                     reachable = true;                 }             }         }         return reachable;     }      bool dfs(int v){         for(int to : g[v]){             int u = matchR[to];             if(u < 0 || (u >= 0 && dist[u] == dist[v] + 1 && dfs(u))){                 matchL[v] = to;                 matchR[to] = v;                 return true;             }         }         dist[v] = -1;         return false;     }      int max_matching(){         int res = 0;         while(bfs()){             for(int i = 0;i < nL;i++){                 if(matchL[i] == -1){                     if(dfs(i)){                         res++;                     }                 }             }         }         return res;     } };  ``` "
  },
  {
    "title": "便利なやつ",
    "url": "便利なやつ.html",
    "content": "# 便利なやつ  - [string部分一致確認](string部分一致.md) "
  },
  {
    "title": "分数",
    "url": "分数.html",
    "content": "# 分数  分数を扱える構造体  ``` + - * / ができる ``` あまり大きくしすぎると壊れる  比較演算とsortがそのまま使える   ## 初期化  ft x = {3,4}  // ４分の３    ```cpp class ft{ public:     long long si, bo; // si/bo      ft(long long s=0, long long b=1){         si = s; bo = b;         normalize();     }      void normalize(){         if(bo < 0) si = -si, bo = -bo;         long long g = gcd(llabs(si), llabs(bo));         si /= g;         bo /= g;     }      // 加算     ft operator+(const ft& x) const {         long long g = gcd(bo, x.bo);         __int128 nb = (__int128)bo / g * x.bo;         __int128 ns =             (__int128)si * (x.bo / g)           + (__int128)x.si * (bo / g);         return ft((long long)ns, (long long)nb);     }      // 減算     ft operator-(const ft& x) const {         long long g = gcd(bo, x.bo);         __int128 nb = (__int128)bo / g * x.bo;         __int128 ns =             (__int128)si * (x.bo / g)           - (__int128)x.si * (bo / g);         return ft((long long)ns, (long long)nb);     }      // 乗算     ft operator*(const ft& x) const {         long long g1 = gcd(llabs(si), llabs(x.bo));         long long g2 = gcd(llabs(x.si), llabs(bo));         __int128 ns = (__int128)(si/g1) * (x.si/g2);         __int128 nb = (__int128)(bo/g2) * (x.bo/g1);         return ft((long long)ns, (long long)nb);     }      // 除算     ft operator/(const ft& x) const {         assert(x.si != 0);         long long g1 = gcd(llabs(si), llabs(x.si));         long long g2 = gcd(llabs(x.bo), llabs(bo));         __int128 ns = (__int128)(si/g1) * (x.bo/g2);         __int128 nb = (__int128)(bo/g2) * (x.si/g1);         return ft((long long)ns, (long long)nb);     }      // 比較     bool operator<(const ft& x) const {         return (__int128)si * x.bo < (__int128)x.si * bo;     }     bool operator==(const ft& x) const {         return si == x.si && bo == x.bo;     } };   ``` "
  },
  {
    "title": "区間最大代入遅延セグ木",
    "url": "区間最大代入遅延セグ木.html",
    "content": "# 区間最大区間代入遅延セグ木  ```cpp class lst{     public :      const int inf = 1e9;     vector<int> seg,lazy;     int siz = 1;     vector<bool> d;     lst(int n,int x){         while(siz < n){             siz *= 2;         }         seg.assign(siz*2,x);         lazy.assign(siz*2,0);         d.assign(siz*2,false);     }     void push(int pos){         if(!d[pos])return;         seg[pos] = lazy[pos];         d[pos] = false;         if(pos < siz){             lazy[pos*2] = seg[pos];             lazy[pos*2+1] = seg[pos];             d[pos*2] = true;             d[pos*2+1] = true;         }     }     void range_assign(int l,int r,int x){         range_assign(l,r,x,1,0,siz);     }     int range_max(int l,int r){         return range_max(l,r,1,0,siz);     }     private :     void range_assign(int l,int r,int x,int pos,int a,int b){         push(pos);         if (r <= a || b <= l) return;         if(l <= a && b <= r){             seg[pos] = x;             lazy[pos] = x;             d[pos] = true;             return;         }          int mid = (a+b)/2;         range_assign(l,r,x,pos*2,a,mid);         range_assign(l,r,x,pos*2+1,mid,b);         seg[pos] = max(seg[pos*2],seg[pos*2+1]);     }     int range_max(int l,int r,int pos,int a,int b){         push(pos);         if(r <= a || b <= l) return -inf;         if(l <= a && b <= r){             return seg[pos];         }         int mid = (a+b)/2;         return max(             range_max(l,r,pos*2,a,mid),             range_max(l,r,pos*2+1,mid,b)         );     } };  ``` "
  },
  {
    "title": "区間最小代入遅延セグ木",
    "url": "区間最小代入遅延セグ木.html",
    "content": "# 区間最小区間代入遅延セグ木  ```cpp class lst{     public :      const int inf = 1e9;     vector<int> seg,lazy;     int siz = 1;     vector<bool> d;     lst(int n,int x){         while(siz < n){             siz *= 2;         }         seg.assign(siz*2,x);         lazy.assign(siz*2,0);         d.assign(siz*2,false);     }     void push(int pos){         if(!d[pos])return;         seg[pos] = lazy[pos];         d[pos] = false;         if(pos < siz){             lazy[pos*2] = seg[pos];             lazy[pos*2+1] = seg[pos];             d[pos*2] = true;             d[pos*2+1] = true;         }     }     void range_assign(int l,int r,int x){         range_assign(l,r,x,1,0,siz);     }     int range_min(int l,int r){         return range_min(l,r,1,0,siz);     }     private :     void range_assign(int l,int r,int x,int pos,int a,int b){         push(pos);         if (r <= a || b <= l) return;         if(l <= a && b <= r){             seg[pos] = x;             lazy[pos] = x;             d[pos] = true;             return;         }          int mid = (a+b)/2;         range_assign(l,r,x,pos*2,a,mid);         range_assign(l,r,x,pos*2+1,mid,b);         seg[pos] = min(seg[pos*2],seg[pos*2+1]);     }     int range_min(int l,int r,int pos,int a,int b){         push(pos);         if(r <= a || b <= l) return inf;         if(l <= a && b <= r){             return seg[pos];         }         int mid = (a+b)/2;         return min(             range_min(l,r,pos*2,a,mid),             range_min(l,r,pos*2+1,mid,b)         );     } };  ``` "
  },
  {
    "title": "座標圧縮",
    "url": "座標圧縮.html",
    "content": "# 座標圧縮  結果を入れるmap、逆の復元用のvector、圧縮したいvector　を入れる  mapに圧縮前の座礁を入れると圧縮後の座標が帰ってくる  vectorに圧縮後の座標を入れると圧縮前の座標が帰ってくる  ```cpp void ash(map<int,int>& m,vector<int>& g,vector<int> v){     int n = v.size();     m.clear();     sort(v.begin(),v.end());     int j = 0;     for(int i = 0;i < n;i++){         if(m.count(v[i]))continue;         m[v[i]] = j;         while ((int)g.size() <= j) g.push_back(0);         g[j] = v[i];         j++;     }     return ; } ``` "
  },
  {
    "title": "強連結成分分解",
    "url": "強連結成分分解.html",
    "content": "# 強連結成分分解  強連結成分それぞれをvectorにまとめたvviでreturnが来る  scc( 頂点数　、　vviの形のグラフ　）　でできる  ```cpp vector<vector<int>> scc(int n,const vector<vector<int>>& v){     vector<vector<int>> vv(n);     for(int i = 0;i < n;i++){         for(int j = 0;j < v[i].size();j++){             vv[v[i][j]].push_back(i);         }     }     vector<int> res;     vector<bool> visited(n,false);     function<void(int)> f = [&](int pos){         visited[pos] = true;         for(int i : v[pos]){             if(!visited[i])f(i);         }         res.push_back(pos);     };     for(int i = 0;i < n;i++){         if(!visited[i]){             f(i);         }     }     vector<vector<int>> ans;     visited.assign(n,false);     for(int i = res.size()-1; i >= 0;i--){         if(visited[res[i]])continue;         vector<int> p = {res[i]};         function<void(int)> d = [&](int pos){             visited[pos] = true;             for(int i : vv[pos]){                 if(visited[i])continue;                 p.push_back(i);                 d(i);             }         };         d(res[i]);         ans.push_back(p);     }     return ans; } ``` "
  },
  {
    "title": "数列",
    "url": "数列.html",
    "content": "# 数列   - [循環配列での長さwの範囲の和の最大値](rmax.md)  - [循環配列での長さwの範囲の和の最小値](rmin.md)  - [最長増加部分列](最長増加部分列.md)  - [中央値](中央値.md)  - [転倒数](転倒数.md) "
  },
  {
    "title": "数字桁数",
    "url": "数字桁数.html",
    "content": "# 数字桁数  ket(x)でxの桁数が返ってくる  ```cpp  int ket(int n){     int ans = 0;     while(n != 0){         ans++;         n /= 10;     }     return ans; }  ``` "
  },
  {
    "title": "数学まとめ",
    "url": "数学まとめ.html",
    "content": "# 数学  - [素数](素数まとめ.md) - [N進数変換](N進数変換.md) - [数字桁数カウント](数字桁数.md) - [数列](数列.md) - [分数](分数.md) "
  },
  {
    "title": "最大フロー",
    "url": "最大フロー.html",
    "content": "# 最大フロー  add(u,v,f)  u ~ v にcapがfの辺を追加して  flow(s,t) で結果が出てくる   ```cpp class din{      struct edge{         int to;         int cap;         int rev;     };      public :      int n;     vector<vector<edge>> g;     vector<int> level;     vector<int> ite;      din(int x){         n = x;         g.resize(n);         level.resize(n);         ite.resize(n);     }      void add(int from,int to,int cap){         g[from].push_back(edge{to,cap,(int)g[to].size()});         g[to].push_back(edge{from,0,(int)g[from].size()-1});     }      bool bfs(int s,int t){         level.assign(n,-1);         queue<int> q;         q.push(s);         level[s] = 0;         while(q.size()!=0){             int pos = q.front();             q.pop();             for(const edge& e : g[pos]){                 if(e.cap > 0 && level[e.to] < 0){                     level[e.to] = level[pos]+1;                     q.push(e.to);                 }             }         }         return level[t] >= 0;     }     int dfs(int v,int t,int f){         if(v==t)return f;         for(int &i = ite[v];i < (int)g[v].size();i++){             edge& e = g[v][i];             if(e.cap > 0 && level[v] < level[e.to]){                 int d = dfs(e.to,t,min(f,e.cap));                 if(d > 0){                     e.cap -= d;                     g[e.to][e.rev].cap += d;                     return d;                 }             }         }         return 0;     }     int flow(int s,int t){         int ans = 0;         while(1){             if(!bfs(s,t))break;             ite.assign(n,0);             int f = dfs(s,t,INF);             while(1){                 if(f>0){                     ans += f;                     f = dfs(s,t,INF);                 }                 else{                     break;                 }             }                      }         return ans;     }  };  ``` # 辺を復元したい   ```cpp  class din{      struct edge{         int to;         int cap;         int rev;     };      public :      int n;     vector<vector<edge>> g;     vector<int> level;     vector<int> ite;      din(int x){         n = x;         g.resize(n);         level.resize(n);         ite.resize(n);     }      void add(int from,int to,int cap){         g[from].push_back(edge{to,cap,(int)g[to].size()});         g[to].push_back(edge{from,0,(int)g[from].size()-1});     }      bool bfs(int s,int t){         level.assign(n,-1);         queue<int> q;         q.push(s);         level[s] = 0;         while(q.size()!=0){             int pos = q.front();             q.pop();             for(const edge& e : g[pos]){                 if(e.cap > 0 && level[e.to] < 0){                     level[e.to] = level[pos]+1;                     q.push(e.to);                 }             }         }         return level[t] >= 0;     }     int dfs(int v,int t,int f){         if(v==t)return f;         for(int &i = ite[v];i < (int)g[v].size();i++){             edge& e = g[v][i];             if(e.cap > 0 && level[v] < level[e.to]){                 int d = dfs(e.to,t,min(f,e.cap));                 if(d > 0){                     e.cap -= d;                     g[e.to][e.rev].cap += d;                     return d;                 }             }         }         return 0;     }     int flow(int s,int t,vector<pair<int,int>>& res){         int ans = 0;         while(1){             if(!bfs(s,t))break;             ite.assign(n,0);             int f = dfs(s,t,INF);             while(1){                 if(f>0){                     ans += f;                     f = dfs(s,t,INF);                 }                 else{                     break;                 }             }                     }         rep(i,n){             for(edge& e : g[i]){                 if(e.to==s || e.to==t)continue;                 if(e.cap==0){                     res.push_back({i,e.to});                 }             }         }         return ans;     }     int flow(int s,int t){         int ans = 0;         while(1){             if(!bfs(s,t))break;             ite.assign(n,0);             int f = dfs(s,t,INF);             while(1){                 if(f>0){                     ans += f;                     f = dfs(s,t,INF);                 }                 else{                     break;                 }             }                     }         return ans;     } };   ``` "
  },
  {
    "title": "最小全域木",
    "url": "最小全域木.html",
    "content": "# 無向グラフの最小全域木   vector<vector<pair<int,int>>> の状態のグラフを入れる  最小全域木のコストが返ってくる  非連結の場合は-1が返ってくる   ```cpp  long long cost(vector<vector<pair<long long,long long>>>& v){     long long n = v.size();     long long ans = 0;     dsu d(n);     priority_queue<pair<long long,pair<long long,long long>>,vector<pair<long long,pair<long long,long long>>>,greater<pair<long long,pair<long long,long long>>>> q;     rep(i,n)for(pair<long long,long long> p : v[i]){         if(p.first > i){             q.push({p.second,{i,p.first}});         }     }     while(q.size()!=0){         long long w = q.top().first;         long long x = q.top().second.first;         long long y = q.top().second.second;         q.pop();         if(!d.same(x,y)){             ans += w;             d.merge(x,y);         }     }     if(d.size(0)!=n)return -1;     return ans; }  ```   # 最小全域木の内容が欲しい場合  ```cpp  vector<pair<long long,long long>>  cost(vector<vector<pair<long long,long long>>>& v){     long long n = v.size();     vector<pair<long long,long long>> ans;     dsu d(n);     priority_queue<pair<long long,pair<long long,long long>>,vector<pair<long long,pair<long long,long long>>>,greater<pair<long long,pair<long long,long long>>>> q;     rep(i,n)for(pair<long long,long long> p : v[i]){         if(p.first > i){             q.push({p.second,{i,p.first}});         }     }     while(q.size()!=0){         long long w = q.top().first;         long long x = q.top().second.first;         long long y = q.top().second.second;         q.pop();         if(!d.same(x,y)){             d.merge(x,y);             ans.push_back({x,y});         }     }     if(d.size(0)!=n)return {{-1,-1}};     return ans; }  ``` "
  },
  {
    "title": "最長増加部分列",
    "url": "最長増加部分列.html",
    "content": "# 最長増加部分列  lis_sizeで最長部分増加列の長さ  los_posでそれぞれの位置までの最長増加部分列の長さが記録されたvectorが帰っってくる  ```cpp      int lis_size(vector<int> v){         vector<int> dp;         int n = v.size();         for(int i : v){                             auto it = lower_bound(dp.begin(),dp.end(),i);             if(it == dp.end())dp.push_back(i);             else *it = i;         }         return dp.size();     }     vector<int> lis_pos(vector<int> v){         vector<int> dp;         int n = v.size();         vector<int> ans(n);         for(int j = 0;j < n;j++){             int i = v[j];             auto it = lower_bound(dp.begin(),dp.end(),i);             if(it == dp.end()){                 dp.push_back(i);                 ans[j] = dp.size();             }             else{                 *it = i;                 ans[j] = (it - dp.begin())+1;             }         }         return ans;     }  ``` "
  },
  {
    "title": "木直径",
    "url": "木直径.html",
    "content": "# 木の直径を求める  cho(vvi) vviのグラフを入れる  木の直径が返ってくる    ```cpp int cho(vector<vector<int>>& v){     int n = v.size();     vector<int> go(n,-1);     queue<int> q;     q.push(0);     go[0] = 0;     while(q.size()!=0){         int pos = q.front();         q.pop();         for(int i : v[pos]){             if(go[i] == -1){                 go[i] = go[pos]+1;                 q.push(i);             }         }     }     int st = max_element(go.begin(),go.end())-go.begin();     q.push(st);     go.assign(n,-1);     go[st] = 0;     while(q.size()!=0){         int pos = q.front();         q.pop();         for(int i : v[pos]){             if(go[i] == -1){                 go[i] = go[pos]+1;                 q.push(i);             }         }     }     return *max_element(go.begin(),go.end()); } ```  # 直径になるペアが知りたい場合  ```cpp  pair<int,int> cho(vector<vector<int>>& v){     int n = v.size();     vector<int> go(n,-1);     queue<int> q;     q.push(0);     go[0] = 0;     while(q.size()!=0){         int pos = q.front();         q.pop();         for(int i : v[pos]){             if(go[i] == -1){                 go[i] = go[pos]+1;                 q.push(i);             }         }     }     int st = max_element(go.begin(),go.end())-go.begin();     q.push(st);     go.assign(n,-1);     go[st] = 0;     while(q.size()!=0){         int pos = q.front();         q.pop();         for(int i : v[pos]){             if(go[i] == -1){                 go[i] = go[pos]+1;                 q.push(i);             }         }     }     return {st,max_element(go.begin(),go.end()) - go.begin()}; }  ```  "
  },
  {
    "title": "答えが広義短調増加になる問題の二分探索",
    "url": "答えが広義短調増加になる問題の二分探索.html",
    "content": "# 答えが広義短調増加となる問題での特定の値の範囲を求める二分探索   int test(mid)  でmid の時の値を返す関数を作っておく必要がある  bs(k) = 答えがkとなる範囲を{L,R}のpairで返す  ```cpp  pair<int,int> bs(int k){     int big,small;     int l = 0;     int r = INF;     while(l+1 < r){    // find big         int mid = (l+r)/2;         int res = test(mid);         if(res > k) r = mid;         else l = mid;     }     big = l;     l = 0;     r = INF;     while(l+1 < r){    // find small         int mid = (l+r)/2;         int res = test(mid);         if(res >= k)r = mid;         else l = mid;     }         small = r;     if(small > big) return {-1, -1};     return {small,big}; }  ``` "
  },
  {
    "title": "答えが短調非減少になる問題の二分探索",
    "url": "答えが短調非減少になる問題の二分探索.html",
    "content": "# 短調非増加の答えでの値Kの範囲   int test(mid) の関数をあらかじめ作っておく必要がある  bs(k) = 答えがkになる範囲の{L,R}をpairで返す  ```cpp  pair<int,int> bs(int k){      int big,small;     int l = 0;     int r = INF;     while(l+1 < r){    // find big         int mid = (l+r)/2;         int res = test(mid);         if(res >= k){             l = mid;         }         else{             r = mid;         }     }     big = l;     l = 0;     r = INF;     while(l+1 < r){    // find small         int mid = (l+r)/2;         int res = test(mid);         if(res > k){             l = mid;         }         else{             r = mid;         }     }         small = r;     return {small,big}; }  ``` "
  },
  {
    "title": "答えでlower_bound",
    "url": "答えでlower_bound.html",
    "content": "# 答えでlower_bound   intを返すtest()を作っておく必要がある  ```cpp  int bs(int x){     // xについてlower_bound     int l = -1;     int r = INF;     while(l+1 < r){         int mid = (l+r)/2;         if(test(mid) >= x)r = mid;         else l = mid;     }     return r; }  ``` "
  },
  {
    "title": "答えでupper_bound",
    "url": "答えでupper_bound.html",
    "content": "# 答えでupper_bound   intを返すtest()を作っておく必要がある  ```cpp  int bs(int x){     // xについてupper_bound     int l = -1;     int r = INF;     while(l+1 < r){         int mid = (l+r)/2;         if(test(mid) > x)r = mid;         else l = mid;     }     return r; }  ``` "
  },
  {
    "title": "答えで二分探索",
    "url": "答えで二分探索.html",
    "content": "# 答えで二分探索  boolを返すtestという関数にmidを入れれば使える状態にしておく必要がある    # 答えの最小化  true true **true** false false   このtrueとなる時の値を返す  ```cpp  int bs_min(){     long long l = 0;     long long r = 1e18;     while (r - l > 1) {         long long mid = (l + r) / 2;         if (test(mid)) {             r = mid;              } else {             l = mid;              }     }     return r; }  ```   "
  },
  {
    "title": "素因数分解pi",
    "url": "素因数分解pi.html",
    "content": "# 素因数分解　pair int,int   ```cpp vector<pair<int,int>>  p(int n){     vector<pair<int,int>> ans;     int x = n;     int k = 0;     while(x % 2 == 0){         k++;         x /= 2;     }     if(k != 0){         ans.push_back({2,k});     }     for(int i = 3;i * i <= n;i+=2){         int cnt = 0;         while(x % i == 0){             cnt++;             x /= i;         }         if(cnt != 0){             ans.push_back({i,cnt});         }         if(x == 1){             break;         }     }     if(x!=1)ans.push_back({x,1});     return ans; }; ``` "
  },
  {
    "title": "素因数分解vi",
    "url": "素因数分解vi.html",
    "content": "# 素因数分解 vector int   ```cpp  vector<int> p(int n){     vector<int> ans;     int x = n;     while(x % 2 == 0){         x /= 2;         ans.push_back(2);     }     for(int i = 3;i * i <= n;i+=2){         while(x % i == 0){             x /= i;             ans.push_back(i);         }         if(x == 1){             break;         }     }     if(x!=1)ans.push_back(x);     return ans; };  ``` "
  },
  {
    "title": "素数まとめ",
    "url": "素数まとめ.html",
    "content": "# 素数のあれこれ  - [素因数分解vi](素因数分解vi.md) - [素因数分解pi](素因数分解pi.md) - [素数列挙](エラトステネスの篩.md) -  "
  },
  {
    "title": "累積和",
    "url": "累積和.html",
    "content": "# 累積和をやるためのライブラリ   rui R(v)でvを累積和にしたRを作れる  queryで(l,r)の範囲の和を求められる   ```cpp template<typename T> class rui{     public:     vector<T> v;     rui(const vector<T>& a){         v = a;         for(int i = 1;i < a.size();i++){             v[i] += v[i-1];         }     }     T query(int l,int r){         if(l == 0){             return v[r];         }         else{             return v[r] - v[l-1];         }     } }; ``` "
  },
  {
    "title": "累積和まとめ",
    "url": "累積和まとめ.html",
    "content": "# 累積和  - [累積和](累積和.md) - [二次元累積和](二次元累積和.md) - [imos](imos.md) - [imos2D](imos2D.md) "
  },
  {
    "title": "転倒数",
    "url": "転倒数.html",
    "content": "# 転倒数  ten(v)に入れたら勝手に座標圧縮されて転倒数が帰ってくる  セグ木が一緒についてきてるのでセグ木を別で定義してる場合は気を付ける   ```cpp  class st{ public:     long long siz = 1;     vector<long long> v;     st (long long n){         siz = 1;         while(siz < n)siz *= 2;         v.assign(2*siz,0);     }     void plus(long long i){         i += siz;         v[i]++;         while(i > 1){             i /= 2;             v[i] = v[i*2]+v[i*2+1];         }     }      long long query(long long L, long long R){   // 添字、L , R         long long ans = 0;         function<void(long long,long long,long long)> f = [&](long long s,long long l,long long r){             if(l >= L && r <= R){                 ans += v[s];                 return;             }             if(r < L || l > R)return;             f(s*2,l,(l+r)/2);             f(s*2+1,(l+r)/2+1,r);             return;         };         f(1,0,siz-1);         return ans;     } }; void ash(map<long long,long long>& m,vector<long long> v){     long long n = v.size();     m.clear();     sort(v.begin(),v.end());     long long j = 0;     for(long long i = 0;i < n;i++){         if(m.count(v[i]))continue;         m[v[i]] = j;         j++;     }     return ; } long long ten(vector<long long> v){     long long n = v.size();     map<long long,long long> m;     ash(m,v);     st seg(m.size());     long long ans = 0;     for(int i = 0;i < n;i++){         ans += seg.query(m[v[i]]+1,m.size()-1);         seg.plus(m[v[i]]);     }     return ans; }  ```  # 逆転倒数  ```cpp   class st{ public:     long long siz = 1;     vector<long long> v;     st (long long n){         siz = 1;         while(siz < n)siz *= 2;         v.assign(2*siz,0);     }     void plus(long long i){         i += siz;         v[i]++;         while(i > 1){             i /= 2;             v[i] = v[i*2]+v[i*2+1];         }     }      long long query(long long L, long long R){   // 添字、L , R         long long ans = 0;         function<void(long long,long long,long long)> f = [&](long long s,long long l,long long r){             if(l >= L && r <= R){                 ans += v[s];                 return;             }             if(r < L || l > R)return;             f(s*2,l,(l+r)/2);             f(s*2+1,(l+r)/2+1,r);             return;         };         f(1,0,siz-1);         return ans;     } }; void ash(map<long long,long long>& m,vector<long long> v){     long long n = v.size();     m.clear();     sort(v.begin(),v.end());     long long j = 0;     for(long long i = 0;i < n;i++){         if(m.count(v[i]))continue;         m[v[i]] = j;         j++;     }     return ; } long long ten(vector<long long> v){     long long n = v.size();     map<long long,long long> m;     ash(m,v);     st seg(m.size());     long long ans = 0;     for(int i = 0;i < n;i++){         ans += seg.query(m[v[i]]+1,m.size()-1);         seg.plus(m[v[i]]);     }     return ans; }   ``` "
  }
]