[
  {
    "title": "Né€²æ•°å¤‰æ›",
    "url": "Né€²æ•°å¤‰æ›.html",
    "content": "# Né€²æ•°å¤‰æ›  ## 10é€²æ•°ã®æ™‚ã¯intã‚’ä½¿ã„ä»–ã®ã¨ãã¯stringã‚’ä½¿ã£ã¦ã„ã‚‹   # 10 -> N f(n,N)ã€€ã§ä»»æ„ã®10é€²æ•°n ã‚’Né€²æ•°ã«å¤‰æ›ã§ãã‚‹  ```cpp  string f(int n,int N){     string ans = \"\";     while (n) {         ans.push_back('0' + n % N);         n /= N;     }     reverse(ans.begin(),ans.end());     return ans; } ```   # N -> 10  f(s,n) ã§ä»»æ„ã®né€²æ•°(n < 10)ã‚’10é€²æ•°ã«å¤‰æ›ã§ãã‚‹  ```cpp int f(string s, int n){     int v = 0;     for(char c : s){         v = v * N + (c - '0');     }     return v; } ```  # X -> y  ```cpp   // å…ˆé ­ã® 0 ã‚’å‰Šé™¤ void trim(vector<int>& a){     while(a.size() > 1 && a[0] == 0) a.erase(a.begin()); }  // aï¼ˆxé€²æ•°ï¼‰ã‚’ y ã§å‰²ã‚‹ // å•†ã‚’ a ã«æ ¼ç´ã—ã€ä½™ã‚Šã‚’è¿”ã™ int div_mod(vector<int>& a, int x, int y){     vector<int> q;     int cur = 0;     for(int d : a){         cur = cur * x + d;         q.push_back(cur / y);         cur %= y;     }     a = q;     trim(a);     return cur; }  // xé€²æ•°(string) â†’ yé€²æ•°(string) string f(string s, int x, int y){     vector<int> a;     for(char c : s) a.push_back(c - '0');     trim(a);      if(a.size() == 1 && a[0] == 0) return \"0\";      string res;     while(!(a.size() == 1 && a[0] == 0)){         int r = div_mod(a, x, y);         res.push_back(char('0' + r));     }     reverse(res.begin(), res.end());     return res; } ```    "
  },
  {
    "title": "RLE",
    "url": "RLE.html",
    "content": "# ãƒ©ãƒ³ã‚°ãƒ¬ã‚¹åœ§ç¸®  string ã‚’å…¥åŠ›  int char ã®ã€€pair ã® vector ã§ãƒªã‚¿ãƒ¼ãƒ³  aaab ->  { 3 , a } , { 1 , b }  ```cpp vector<pair<int,char>> r(string s){     vector<pair<int,char>> ans;     for(int i = 0;i < s.size();i++){         if(ans.size()==0 || ans[ans.size()-1].second != s[i]){             ans.push_back({1,s[i]});         }         else{             ans[ans.size()-1].first++;         }     }      return ans; } ``` "
  },
  {
    "title": "RMaxQ",
    "url": "RMaxQ.html",
    "content": "# RMaxQ segmenttree åå‰(ã‚µã‚¤ã‚º)ã€€ã§å®šç¾©  åå‰.update( i , x ) ã§ i ç•ªç›®ã®è¦ç´ ã‚’ x ã«å¤‰æ›´  åå‰.query( l , r ) ã§ l ã‹ã‚‰ r ã®ç¯„å›²å†…ã®æœ€å¤§å€¤ã‚’å–å¾—  ```cpp  class segmenttree{ public:     long long INF = 1e18;     long long siz = 1;     vector<long long> v;     segmenttree (long long n){         siz = 1;         while(siz < n)siz *= 2;         v.assign(2*siz,-INF);     }     void update(long long i, long long x){         i += siz;         v[i] = x;         while(i > 1){             i /= 2;             v[i] = max(v[i*2],v[i*2+1]);         }     }      long long query(int l,int r){         return query(l,r,1,0,siz-1);     }     private :      long long query(int L,int R,int s,int l,int r){         long long ans = -INF;         if(l >= L && r <= R){             ans = max(ans,v[s]);             return ans;         }         if(r < L || l > R)return -INF;         ans = max(ans,query(L,R,s*2,l,(l+r)/2));         ans = max(ans,query(L,R,s*2+1,(l+r)/2+1,r));         return ans;     } };  ```  "
  },
  {
    "title": "RMinQ",
    "url": "RMinQ.html",
    "content": "# RMinQ  segmenttree åå‰(ã‚µã‚¤ã‚º)ã€€ã§å®šç¾©  åå‰.update( i , x ) ã§ i ç•ªç›®ã®è¦ç´ ã‚’ x ã«å¤‰æ›´  åå‰.query( l , r ) ã§ l ã‹ã‚‰ r ã®ç¯„å›²å†…ã®æœ€å¤§å€¤ã‚’å–å¾—   ```cpp class segmenttree{ public:     long long INF = 1e18;     long long siz = 1;     vector<long long> v;     segmenttree (long long n){         siz = 1;         while(siz < n)siz *= 2;         v.assign(2*siz,INF);     }     void update(long long i, long long x){         i += siz;         v[i] = x;         while(i > 1){             i /= 2;             v[i] = min(v[i*2],v[i*2+1]);         }     }      long long query(int l,int r){         return query(l,r,1,0,siz-1);     }     private :      long long query(int L,int R,int s,int l,int r){         long long ans = INF;         if(l >= L && r <= R){             ans = min(ans,v[s]);             return ans;         }         if(r < L || l > R)return INF;         ans = min(ans,query(L,R,s*2,l,(l+r)/2));         ans = min(ans,query(L,R,s*2+1,(l+r)/2+1,r));         return ans;     } };  ``` "
  },
  {
    "title": "RSQ",
    "url": "RSQ.html",
    "content": "# åŒºé–“å’Œã®ã‚»ã‚°æœ¨   segmenttree åå‰(ã‚µã‚¤ã‚º)ã€€ã§å®šç¾©   åå‰.update( i , x ) ã§ i ç•ªç›®ã®è¦ç´ ã‚’ x ã«å¤‰æ›´   åå‰.query( l , r ) ã§ l ã‹ã‚‰ r ã®ç¯„å›²å†…ã®åˆè¨ˆå€¤ã‚’å–å¾—   ```cpp class segmenttree{ public:     long long siz = 1;     vector<long long> v;     segmenttree (long long n){         siz = 1;         while(siz < n)siz *= 2;         v.assign(2*siz,0);     }     void update(long long i, long long x){         i += siz;         v[i] = x;         while(i > 1){             i /= 2;             v[i] = v[i*2]+v[i*2+1];         }     }      long long query(int l,int r){         return query(l,r,1,0,siz-1);     }     private :      long long query(int L,int R,int s,int l,int r){         long long ans = 0;         if(l >= L && r <= R){             ans += v[s];             return ans;         }         if(r < L || l > R)return 0;         ans += query(L,R,s*2,l,(l+r)/2);         ans += query(L,R,s*2+1,(l+r)/2+1,r);         return ans;     } };  ``` "
  },
  {
    "title": "countmultiset",
    "url": "countmultiset.html",
    "content": "# countãŒé«˜é€Ÿã«è¡Œãˆã‚‹maltiset  ä½¿ã„æ–¹ã¯mulsisetã¨åŒã˜  countãŒlogNã§å®Ÿè¡Œã§ãã‚‹  ```cpp template<typename T> class countable_multiset{     public :     multiset<T> ms;     map<T,int> cnt;     void insert(const T& n){         cnt[n]++;         ms.insert(n);     }     void all_erase(const T& n){         cnt.erase(n);         ms.erase(n);     }     void it_erase(const T& n){         auto it = ms.find(n);         if(it==ms.end())return;         cnt[n] = max(0,cnt[n]-1);         if(cnt[n]==0)cnt.erase(n);         ms.erase(it);     }     int count(const T& n){         if(cnt.count(n))return cnt[n];         return 0;     }     auto find(const T& n){         return ms.find(n);     } }; ``` "
  },
  {
    "title": "imos",
    "url": "imos.html",
    "content": "# imosæ³•ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒª  plus(l,r,x) ã§l~rã¾ã§ã«xã‚’åŠ ç®—ã™ã‚‹  solve() ã‚’ã—ãŸã‚‰å®Œæˆ  ãã“ã‹ã‚‰ã¯æ™®é€šã®vecotrã¨åŒã˜ã‚ˆã†ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹  ```cpp  class imos{     public :      vector<long long> v;     long long n;     imos(long long x){         v.assign(x,0);         n = v.size();     }     void plus(long long l,long long r,long long x){         v[l] += x;         if(r != n-1)v[r+1]-=x;     }     void solve(){         for(long long i = 1;i < n;i++){             v[i] += v[i-1];         }     }     long long at(long long pos){         return v[pos];     }     long long operator[](long long pos) const {         return v[pos];     } };  ``` "
  },
  {
    "title": "imos2D",
    "url": "imos2D.html",
    "content": "# imos2D  ``` (a,b)(   )(   ) (   )(   )(   ) (   )(   )(c,d)   ``` update(a,b,c,d,x)ã§ã“ã“ã®ç¯„å›²ã«+xã§ãã‚‹  build()ã‚’ã‚„ã£ãŸã‚‰OK   ```cpp  class imos2D{     public :     vector<vector<long long>> v;     long long h,w;     imos2D(long long H,long long W){         h = H;         w = W;         v.assign(h,vector<long long>(w));     }     void update(long long a,long long b,long long c,long long d,long long x){         v[a][b]+=x;         if(c+1 < h)v[c+1][b]-=x;         if(d+1 < w)v[a][d+1]-=x;         if(c+1 < h && d+1 < w)v[c+1][d+1]+=x;     }     void build(){         for(long long i = 0;i < h;i++){             for(long long j = 1;j < w;j++){                 v[i][j] += v[i][j-1];             }         }         for(long long j = 0;j < w;j++){             for(long long i = 1;i < h;i++){                 v[i][j] += v[i-1][j];             }         }     }     vector<long long>& operator[](long long i){         return v[i];     }     const vector<long long>& operator[](long long i) const{         return v[i];     } };  ``` "
  },
  {
    "title": "index",
    "url": "index.html",
    "content": "# kansu cpp library  - [ä¸€è¦§](ä¸€è¦§.md)  - [template](template.md)    - [ç´¯ç©å’Œ](ç´¯ç©å’Œã¾ã¨ã‚.md)    - [æ•°å­¦](æ•°å­¦ã¾ã¨ã‚.md)    - [ã‚°ãƒ©ãƒ•](ã‚°ãƒ©ãƒ•ã¾ã¨ã‚.md)    - [ãƒ‡ãƒ¼ã‚¿æ§‹é€ ](ãƒ‡ãƒ¼ã‚¿æ§‹é€ .md)  - [äºŒåˆ†æ¢ç´¢](äºŒåˆ†æ¢ç´¢.md)  - [ãã®ä»–å…¸å‹](ãã®ä»–å…¸å‹.md)           "
  },
  {
    "title": "order_statistic_tree",
    "url": "order_statistic_tree.html",
    "content": "# order_statistic_tree  insert,erase,find,cnt,order,lower_bound,upper_bound,miman,ika  ãŒå¯èƒ½  ```cpp   class trp{     const long long INF = 1e18;     struct node{         int key;         int priority;         int siz;         node* left;         node* right;         node(int k,int p){             key = k;             priority = p;             siz = 1;             left = nullptr;             right = nullptr;         }     };      node* root;       bool find(node* t,int x){         if(t == nullptr)return false;         if(t -> key == x)return true;         if(x < t->key)return find(t->left,x);         else return find(t->right,x);     }     node* merge(node* l,node* r){         if(l == nullptr)return r;         if(r == nullptr)return l;         if(l->priority > r->priority){             l-> right = merge(l->right,r);             update(l);             return l;         }         else{             r->left = merge(l,r->left);             update(r);             return r;         }     }     pair<node*,node*> split(node* t,int x){         if(t==nullptr)return {nullptr,nullptr};         if(x <= t->key){             pair<node*,node*> p = split(t->left,x);             t -> left = p.second;             update(t);             return {p.first,t};         }         else{             pair<node*,node*> p = split(t->right,x);             t -> right = p.first;             update(t);             return {t,p.second};                     }     }     int size(node* t){         if(t == nullptr)return 0;         else return t -> siz;     }     void update(node* t){         if(t == nullptr)return;         t -> siz = 1 + size(t->left)+size(t->right);     }     int cnt(node* t,int k){         if(t == nullptr)return -INF;         int lsiz = size(t->left);         if(lsiz > k){             return cnt(t -> left,k);         }         else if(k==lsiz){             return t->key;         }         else{             return cnt(t -> right,k - lsiz - 1);         }     }     int order(node* t,int x){         if(t == nullptr)return 0;         if(x <= t->key){             return order(t -> left,x);         }         else{             return size(t -> left) + 1 + order(t->right,x);         }     }     node* lower_bound(node* t, int x){         if(t == nullptr) return nullptr;          if(t->key < x){             return lower_bound(t->right, x);         }         else{             node* res = lower_bound(t->left, x);             if(res != nullptr) return res;             else return t;         }     }     node* upper_bound(node* t, int x){         if(t == nullptr) return nullptr;          if(t->key <= x){             return upper_bound(t->right, x);         }         else{             node* res = upper_bound(t->left, x);             if(res != nullptr) return res;             else return t;         }     }     node* ika(node* t,int x){         if(t==nullptr)return nullptr;         if(t -> key > x){             return ika(t->left,x);         }         else{             node*res = ika(t->right,x);             if(res != nullptr)return res;             else return t;         }     }       public :      trp(){         root = nullptr;     }     bool find(int x){         return find(root,x);     }     void insert(int x){         if(find(x))return;         pair<node*,node*> p = split(root,x);         node* r = p.second;         node* l = p.first;         node* n = new node(x,rand());         root = merge(merge(l,n),r);     }     void erase(int x){         if(!find(x))return ;         pair<node*,node*> a = split(root,x);         pair<node*,node*> b = split(a.second,x+1);         root = merge(a.first,b.second);     }     int cnt(int k){         return  cnt(root,k);     }     int order(int x){         return order(root,x);     }     int lower_bound(int x){         node* res = lower_bound(root, x);         if(res == nullptr) return -INF;         return res->key;     }     int upper_bound(int x){         node* res = upper_bound(root, x);         if(res == nullptr) return -INF;         return res->key;     }     int miman(int x){         int k = order(x) -1;         if(k < 0)return -INF;         return cnt(k);     }     int ika(int x){         node* k = ika(root,x);         if(k == nullptr)return -INF;         else return k->key;     } };  ``` "
  },
  {
    "title": "rmax",
    "url": "rmax.html",
    "content": "# å¾ªç’°é…åˆ—ã§ã®é•·ã•wã®åŒºé–“ã®å’Œã®æœ€å¤§å€¤  å¾ªç’°ã•ã›ã‚‹å‰ã®é…åˆ—ã¨é•·ã•Wã‚’å…¥ã‚Œã‚‹   ```cpp      long long rmax(vector<int> v,long long w){         int n = v.size();         rep(i,n)v.push_back(v[i]);         n *= 2;         if(w >= n/2){             long long ans = 0;             rep(i,n/2)ans += v[i];             return ans;         }         long long sum = 0;         rep(i,w)sum += v[i];         long long ans = sum;         for(long long i = 0;i < n/2-1;i++){             sum -= v[i];             sum += v[i+w];             ans = max(ans,sum);         }         return ans;     }  ``` "
  },
  {
    "title": "rmin",
    "url": "rmin.html",
    "content": "# å¾ªç’°é…åˆ—ã§ã®é•·ã•wã®åŒºé–“ã®å’Œã®æœ€å°å€¤  å¾ªç’°ã•ã›ã‚‹å‰ã®é…åˆ—ã¨é•·ã•Wã‚’å…¥ã‚Œã‚‹   ```cpp      long long rmax(vector<int> v,long long w){         int n = v.size();         rep(i,n)v.push_back(v[i]);         n *= 2;         if(w >= n/2){             long long ans = 0;             rep(i,n/2)ans += v[i];             return ans;         }         long long sum = 0;         rep(i,w)sum += v[i];         long long ans = sum;         for(long long i = 0;i < n/2-1;i++){             sum -= v[i];             sum += v[i+w];             ans = min(ans,sum);         }         return ans;     }  ``` "
  },
  {
    "title": "stringéƒ¨åˆ†ä¸€è‡´",
    "url": "stringéƒ¨åˆ†ä¸€è‡´.html",
    "content": "# stringéƒ¨åˆ†ä¸€è‡´ç¢ºèª   ```cpp  bool same(string& s,string& t,int x){     // sã®xæ–‡å­—ç›®ã‹ã‚‰ãŒtã¨ä¸€è‡´ã™ã‚‹ãªã‚‰true     int j = 0;     for(int i = x;i < x+t.size();i++){         if(i >= s.size())return false;         if(j >= t.size())return false;         if(s[i]!=t[j]){             return false;         }         j++;     }     return true; }  ``` "
  },
  {
    "title": "template",
    "url": "template.html",
    "content": "--- layout: default ---  # ã‚ˆãä½¿ã†ã‚„ã¤       ```cpp #include <bits/stdc++.h> #include <atcoder/all> using namespace atcoder; using namespace std; using ll = long long; #define rep(i , n) for(int i=0; i< (int)(n); i++) #define int long long const ll INF = 1e18; const int inf = 1e9; const int mod = 998244353; template<class T> void chmin(T& a, T b){ if(a > b) a = b; } template<class T> void chmax(T& a, T b){ if(a < b) a = b; } void yes(){cout << \"Yes\" << endl;} void no(){cout << \"No\" << endl;} int32_t main(){     ios::sync_with_stdio(false);     cin.tie(nullptr);      }   ``` "
  },
  {
    "title": "treapæœ¨",
    "url": "treapæœ¨.html",
    "content": "# treapæœ¨  insert  find  erase   ãŒã§ãã‚‹   ```cpp  class trp{     struct node{         int key;         int priority;         node* left;         node* right;         node(int k,int p){             key = k;             priority = p;             left = nullptr;             right = nullptr;         }     };      node* root;       bool find(node* t,int x){         if(t == nullptr)return false;         if(t -> key == x)return true;         if(x < t->key)return find(t->left,x);         else return find(t->right,x);     }     node* merge(node* l,node* r){         if(l == nullptr)return r;         if(r == nullptr)return l;         if(l->priority > r->priority){             l-> right = merge(l->right,r);             return l;         }         else{             r->left = merge(l,r->left);             return r;         }     }     pair<node*,node*> split(node* t,int x){         if(t==nullptr)return {nullptr,nullptr};         if(x <= t->key){             pair<node*,node*> p = split(t->left,x);             t -> left = p.second;             return {p.first,t};         }         else{             pair<node*,node*> p = split(t->right,x);             t -> right = p.first;             return {t,p.second};                     }     }      public :      trp(){         root = nullptr;     }     bool find(int x){         return find(root,x);     }     void insert(int x){         if(find(x))return;         pair<node*,node*> p = split(root,x);         node* r = p.second;         node* l = p.first;         node* n = new node(x,rand());         root = merge(merge(l,n),r);     }     void erase(int x){         if(!find(x))return ;         pair<node*,node*> a = split(root,x);         pair<node*,node*> b = split(a.second,x+1);         root = merge(a.first,b.second);     } };  ``` "
  },
  {
    "title": "unionfind",
    "url": "unionfind.html",
    "content": "# union find   findï¼šæ ¹ã‚’æ±‚ã‚ã‚‹ connectï¼šç¹‹ã’ã‚‹(ã‚‚ã¨ã‚‚ã¨ç¹‹ãŒã£ã¦ãŸã‚‰falseã‚’return) sameï¼šçµåˆã‹åˆ¤å®š sizeï¼šãã®ãƒãƒ¼ãƒ‰ã®é€£çµè¦ç´ æ•°  ```cpp  class UnionFind { public: \t//@brief Union-Findã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ \t//@param n ãƒãƒ¼ãƒ‰æ•° \tUnionFind(int n) : PoS(n, -1) {}  \t//@brief æ ¹ã‚’æ±‚ã‚ã‚‹ \t//@param x ãƒãƒ¼ãƒ‰ç•ªå· \t//@return xã®æ ¹ã®ãƒãƒ¼ãƒ‰ç•ªå· \tint find(int x) { \t\tif (PoS[x] < 0) { \t\t\treturn x; \t\t} \t\treturn (PoS[x] = find(PoS[x])); \t}  \t//@brief æ¥ç¶šã‹ã‚’åˆ¤å®šã™ã‚‹ \t//@param x ãƒãƒ¼ãƒ‰1 \t//@param y ãƒãƒ¼ãƒ‰2 \tbool same(int x, int y) { \t\treturn (find(x) == find(y)); \t}  \t//@brief é€£çµè¦ç´ æ•°ã‚’æ•°ãˆã‚‹ \t//@param x ãƒãƒ¼ãƒ‰ç•ªå· \t//@return xã®é€£çµè¦ç´ æ•° \tint size(int x) { \t\treturn -PoS[find(x)]; \t}  \t//@brief é›†åˆã‚’ç¹‹ã’ã‚‹ \t//@param x ãƒãƒ¼ãƒ‰1 \t//@param y ãƒãƒ¼ãƒ‰2 \t//@return çµåˆãŒè¡ŒãˆãŸã‹(æ—¢ã«çµåˆã—ã¦ã„ãŸ:false) \tbool connect(int x, int y) { \t\tx = find(x); \t\ty = find(y); \t\tif (x == y) return false;  \t\tif (-PoS[x] < -PoS[y]) { \t\t\tstd::swap(x, y); \t\t} \t\tPoS[x] += PoS[y]; \t\tPoS[y] = x; \t\treturn true; \t} private: \t//@brief è¦ªã‚‚ã—ãã¯è¦ç´ æ•°(Parent or Size) \tstd::vector<int> PoS; };  ``` "
  },
  {
    "title": "xorã‚»ã‚°æœ¨",
    "url": "xorã‚»ã‚°æœ¨.html",
    "content": "# xorã®ã‚»ã‚°æœ¨  segmenttree seg(n)  ã‚µã‚¤ã‚ºnã§å®šç¾©  seg.update(i,x) iç•ªç›®ã‚’xã«ã™ã‚‹  seg.query(l,r) l~rã®åŒºé–“ã®xorã‚’å‡ºã™  ```cpp  class segmenttree{ public:     long long INF = 1e18;     long long siz = 1;     vector<long long> v;     segmenttree (long long n){         siz = 1;         while(siz < n)siz *= 2;         v.assign(2*siz,0);     }     void update(long long i, long long x){         i += siz;         v[i] = x;         while(i > 1){             i /= 2;             v[i] = v[i*2]^v[i*2+1];         }     }      long long query(int l,int r){         return query(l,r,1,0,siz-1);     }     private :      long long query(int L,int R,int s,int l,int r){         long long ans = 0;         if(l >= L && r <= R){             ans = ans^v[s];             return ans;         }         if(r < L || l > R)return 0;         ans ^= query(L,R,s*2,l,(l+r)/2);         ans ^= query(L,R,s*2+1,(l+r)/2+1,r);         return ans;     } };  ``` "
  },
  {
    "title": "ãã®ä»–å…¸å‹",
    "url": "ãã®ä»–å…¸å‹.html",
    "content": "# ãã®ä»–å…¸å‹ - [ãƒŠãƒƒãƒ—ã‚¶ãƒƒã‚¯](ãƒŠãƒƒãƒ—ã‚¶ãƒƒã‚¯.md) - [ãƒ©ãƒ³ã‚°ãƒ¬ã‚¹åœ§ç¸®](RLE.md) - [åº§æ¨™åœ§ç¸®](åº§æ¨™åœ§ç¸®.md) - [æœ€é•·å¢—åŠ éƒ¨åˆ†åˆ—](æœ€é•·å¢—åŠ éƒ¨åˆ†åˆ—.md) - [ä¾¿åˆ©ãªã‚„ã¤](ä¾¿åˆ©ãªã‚„ã¤.md) - [ãƒ€ãƒ–ãƒªãƒ³ã‚°](ãƒ€ãƒ–ãƒªãƒ³ã‚°.md) "
  },
  {
    "title": "ã‚¨ãƒ©ãƒˆã‚¹ãƒ†ãƒã‚¹ã®ç¯©",
    "url": "ã‚¨ãƒ©ãƒˆã‚¹ãƒ†ãƒã‚¹ã®ç¯©.html",
    "content": "# ã‚¨ãƒ©ãƒˆã‚¹ãƒ†ãƒã‚¹ã®ç¯© p(n) = n ä»¥ä¸‹ã®ç´ æ•°ã‚’åˆ—æŒ™ã—ã¦vector<int> ã§ãƒªã‚¿ãƒ¼ãƒ³  ```cpp vector<int> p(int n) {     vector<bool> ok(n+1,1);     ok[0] = ok[1] = 0;     for(int i = 2;i*i < n+1;i++){         if(ok[i]){             for(int j = i*i;j < n+1;j += i){                 ok[j] = 0;             }         }     }     vector<int> ans;     rep(i,n+1){         if(ok[i]){             ans.push_back(i);         }     }     return ans; } ``` "
  },
  {
    "title": "ã‚°ãƒ©ãƒ•ã¾ã¨ã‚",
    "url": "ã‚°ãƒ©ãƒ•ã¾ã¨ã‚.html",
    "content": "# ã‚°ãƒ©ãƒ•ã®ã‚ã‚Œã“ã‚Œ  - [å¼·é€£çµæˆåˆ†åˆ†è§£](å¼·é€£çµæˆåˆ†åˆ†è§£.md) - [æœ¨ç›´å¾„](æœ¨ç›´å¾„.md) - [ãƒ•ãƒ­ãƒ¼](ãƒ•ãƒ­ãƒ¼ã¾ã¨ã‚.md) - [ãƒ¯ãƒ¼ã‚·ãƒ£ãƒ«ãƒ•ãƒ­ã‚¤ãƒ‰](ãƒ¯ãƒ¼ã‚·ãƒ£ãƒ«ãƒ•ãƒ­ã‚¤ãƒ‰.md) - [ãƒ€ã‚¤ã‚¯ã‚¹ãƒˆãƒ©](ãƒ€ã‚¤ã‚¯ã‚¹ãƒˆãƒ©.md) - [æœ€å°å…¨åŸŸæœ¨](æœ€å°å…¨åŸŸæœ¨.md) "
  },
  {
    "title": "ã‚»ã‚°æœ¨ã¾ã¨ã‚",
    "url": "ã‚»ã‚°æœ¨ã¾ã¨ã‚.html",
    "content": "# ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæœ¨  - [RmaxQ](RMaxQ.md) - [RminQ](RMinQ.md) - [RsumQ](RSQ.md) - [xorã‚»ã‚°æœ¨](xorã‚»ã‚°æœ¨.md) - [åŒºé–“æœ€å¤§ä»£å…¥é…å»¶ã‚»ã‚°æœ¨](åŒºé–“æœ€å¤§ä»£å…¥é…å»¶ã‚»ã‚°æœ¨.md) - [åŒºé–“æœ€å°ä»£å…¥é…å»¶ã‚»ã‚°æœ¨](åŒºé–“æœ€å°ä»£å…¥é…å»¶ã‚»ã‚°æœ¨.md) "
  },
  {
    "title": "ãƒ€ã‚¤ã‚¯ã‚¹ãƒˆãƒ©",
    "url": "ãƒ€ã‚¤ã‚¯ã‚¹ãƒˆãƒ©.html",
    "content": "# ãƒ€ã‚¤ã‚¯ã‚¹ãƒˆãƒ©  vector<vector<pair<int,int>>>ã®å½¢ã®ã‚°ãƒ©ãƒ•ã‚’æŠ•å…¥  ds(ã‚°ãƒ©ãƒ•,ã‚¹ã‚¿ãƒ¼ãƒˆåœ°ç‚¹)  ã‚¹ã‚¿ãƒ¼ãƒˆè¦–ç‚¹ã‹ã‚‰ã®è·é›¢ãŒè¨˜éŒ²ã•ã‚ŒãŸvectorãŒå¸°ã£ã¦ãã‚‹  è² ã®é‡ã¿ã‚’æŒã¤è¾ºã‚’å…¥ã‚Œã¦ã¯ã„ã‘ãªã„   ```cpp   vector<long long> ds(vector<vector<pair<long long,long long>>>& v,long long str){     long long inf = 1e9;     vector<long long> ans(v.size(),inf);     ans[str] = 0;     priority_queue<pair<long long,long long>,vector<pair<long long,long long>>,greater<pair<long long,long long>>> q;     q.push({0,str});     while(q.size()!=0){         long long cos = q.top().first;         long long pos = q.top().second;         q.pop();         if(cos > ans[pos])continue;         for(pair<long long,long long> i : v[pos]){             if(ans[i.first] > cos + i.second){                 ans[i.first] = cos + i.second;                 q.push({cos+i.second,i.first});             }         }     }     return ans; }  ``` "
  },
  {
    "title": "ãƒ€ãƒ–ãƒªãƒ³ã‚°",
    "url": "ãƒ€ãƒ–ãƒªãƒ³ã‚°.html",
    "content": "# ãƒ€ãƒ–ãƒªãƒ³ã‚°  dub(vector<int>) ã§å®£è¨€ã™ã‚‹  å¼•æ•°ã®vectorã¯ãã‚Œãã‚Œã®å ´æ‰€ã«ã¤ã„ã¦æ¬¡ã®æ—¥ã«è¡Œãå ´æ‰€ã‚’è¨˜éŒ²  query(x,y)ã§ä»Šxã«ã„ã‚‹æ™‚yæ—¥å¾Œã®å ´æ‰€ãŒã‚ã‹ã‚‹  ```cpp  class dub{     public:      vector<vector<int>> d;     int n;     dub(vector<int>& a){          // ä»Šã®å ´æ‰€ i ã€€         // æ¬¡ã®æ—¥ a[i]ã€€         // ã®vectorã‚’å…¥ã‚Œã‚‹          n = a.size();         d.assign(n,vector<int>(64));         rep(i,n){             d[i][0] = a[i];         }         for(int j = 1;j < 64;j++){             for(int i = 0;i < n;i++){                 d[i][j] = d[d[i][j-1]][j-1];             }         }             }     int query(int x,int y){         //  ä»Šxã«ã„ã‚‹æ™‚yæ—¥å¾Œã«ã„ã‚‹ã¨ã“ã‚         bitset<64> b(y);         int now = x;         rep(i,64){             if(b.test(i)){                 now = d[now][i];             }         }            return now;          } };  ``` "
  },
  {
    "title": "ãƒ‡ãƒ¼ã‚¿æ§‹é€ ",
    "url": "ãƒ‡ãƒ¼ã‚¿æ§‹é€ .html",
    "content": "# ãŸã¾ã«ä½¿ãˆã‚‹ã‹ã‚‚ã—ã‚Œãªã„ãƒ‡ãƒ¼ã‚¿æ§‹é€   - [äºŒåˆ†æ¢ç´¢ç”¨vector](äºŒåˆ†æ¢ç´¢ç”¨vector.md) - [countmultiset](countmultiset.md) - [treapæœ¨](treapæœ¨.md) - [order_statistic_tree](order_statistic_tree.md) - [ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæœ¨](ã‚»ã‚°æœ¨ã¾ã¨ã‚.md) - [imos](imos.md) - [imos2D](imos2D.md) - [union_find](unionfind.md) "
  },
  {
    "title": "ãƒŠãƒƒãƒ—ã‚¶ãƒƒã‚¯",
    "url": "ãƒŠãƒƒãƒ—ã‚¶ãƒƒã‚¯.html",
    "content": "[home](README.md)  # ãƒŠãƒƒãƒ—ã‚¶ãƒƒã‚¯  ```cpp int npz(vector<pair<int,int>> v,int w){     //{é‡ã•ã€ä¾¡å€¤}ã€é‡ã•åˆ¶é™     int n = v.size();     vector<vector<int>> dp(n,vector<int>(w+1,-1));     dp[0][0] = 0;     if(v[0].first <= w){         dp[0][v[0].first] = v[0].second;     }     for(int i = 0;i < n-1;i++){         for(int j = 0;j <= w;j++){             if(dp[i][j]==-1)continue;             if(j+v[i+1].first <= w){             dp[i+1][j+v[i+1].first] = max(dp[i+1][j+v[i+1].first],dp[i][j]+v[i+1].second);             }             dp[i+1][j] = max(dp[i+1][j],dp[i][j]);         }        }     int ans = -1;     for(int j = 0;j <= w;j++){         ans = max(ans,dp[n-1][j]);     }      return ans; } ``` "
  },
  {
    "title": "ãƒ•ãƒ­ãƒ¼ã¾ã¨ã‚",
    "url": "ãƒ•ãƒ­ãƒ¼ã¾ã¨ã‚.html",
    "content": "# ãƒ•ãƒ­ãƒ¼ã®ã‚ã‚Œã“ã‚Œ  - [æœ€å¤§ãƒ•ãƒ­ãƒ¼](æœ€å¤§ãƒ•ãƒ­ãƒ¼.md)  - [äºŒéƒ¨ãƒãƒƒãƒãƒ³ã‚°](äºŒéƒ¨ãƒãƒƒãƒãƒ³ã‚°.md) "
  },
  {
    "title": "ãƒ¯ãƒ¼ã‚·ãƒ£ãƒ«ãƒ•ãƒ­ã‚¤ãƒ‰",
    "url": "ãƒ¯ãƒ¼ã‚·ãƒ£ãƒ«ãƒ•ãƒ­ã‚¤ãƒ‰.html",
    "content": "# ãƒ¯ãƒ¼ã‚·ãƒ£ãƒ«ãƒ•ãƒ­ã‚¤ãƒ‰  vvpã®å½¢ã®ã‚°ãƒ©ãƒ•ã‚’å…¥ã‚Œã‚‹  wf(vvp) ã§vviã«å¤‰æ›ã•ã‚Œã¦è¿”ã£ã¦ãã‚‹   ```cpp  vector<vector<int>> wf(vector<vector<pair<int,int>>> v){     int n = v.size();     vector<vector<int>> dis(n);     for(int i = 0;i < n;i++){         vector<int> ans(n,inf);         ans[i] = 0;         priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;         q.push({0,i});         while(q.size()!=0){             int cos = q.top().first;             int pos = q.top().second;             q.pop();             if(ans[pos] < cos)continue;             for(pair<int,int> p : v[pos]){                 if(ans[p.first] > ans[pos]+p.second){                     ans[p.first] = ans[pos]+p.second;                     q.push({ans[pos]+p.second,p.first});                 }             }         }         dis[i] = ans;     }     return dis; }  ``` "
  },
  {
    "title": "ä¸€è¦§",
    "url": "ä¸€è¦§.html",
    "content": " ## ğŸ” æ¤œç´¢  <input type=\"text\" id=\"searchBox\" placeholder=\"æ¤œç´¢...\" style=\"width: 100%; padding: 8px;\"> <ul id=\"searchResults\"></ul>  <script src=\"search.js\"></script>    ---  ## åŸºæœ¬ãƒ»ãƒ†ãƒ³ãƒ—ãƒ¬  - [templaaate](template.md) - [ä¾¿åˆ©ãªã‚„ã¤](ä¾¿åˆ©ãªã‚„ã¤.md)  ---  ## ãƒ‡ãƒ¼ã‚¿æ§‹é€   - [ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã¾ã¨ã‚](ãƒ‡ãƒ¼ã‚¿æ§‹é€ .md) - [ã‚»ã‚°æœ¨ã¾ã¨ã‚](ã‚»ã‚°æœ¨ã¾ã¨ã‚.md) - [RMaxQ](RMaxQ.md) - [RMinQ](RMinQ.md) - [RSQï¼ˆåŒºé–“å’Œï¼‰](RSQ.md) - [xorã‚»ã‚°æœ¨](xorã‚»ã‚°æœ¨.md) - [åŒºé–“æœ€å¤§ä»£å…¥é…å»¶ã‚»ã‚°æœ¨](åŒºé–“æœ€å¤§ä»£å…¥é…å»¶ã‚»ã‚°æœ¨.md) - [åŒºé–“æœ€å°ä»£å…¥é…å»¶ã‚»ã‚°æœ¨](åŒºé–“æœ€å°ä»£å…¥é…å»¶ã‚»ã‚°æœ¨.md) - [treapæœ¨](treapæœ¨.md) - [order statistic tree](order_statistic_tree.md) - [count ãŒé«˜é€Ÿãª multiset](countmultiset.md) - [ä¸­å¤®å€¤](ä¸­å¤®å€¤.md) - [union_find](unionfind.md) - [åˆ†æ•°](åˆ†æ•°.md)  ---  ## ç´¯ç©å’Œãƒ»imos  - [ç´¯ç©å’Œ](ç´¯ç©å’Œ.md) - [ç´¯ç©å’Œã¾ã¨ã‚](ç´¯ç©å’Œã¾ã¨ã‚.md) - [äºŒæ¬¡å…ƒç´¯ç©å’Œ](äºŒæ¬¡å…ƒç´¯ç©å’Œ.md) - [imos æ³•](imos.md) - [äºŒæ¬¡å…ƒ imos](imos2D.md)  ---  ## äºŒåˆ†æ¢ç´¢ãƒ»æ¢ç´¢  - [äºŒåˆ†æ¢ç´¢](äºŒåˆ†æ¢ç´¢.md) - [äºŒåˆ†æ¢ç´¢ç”¨ vector](äºŒåˆ†æ¢ç´¢ç”¨vector.md) - [ç­”ãˆã§äºŒåˆ†æ¢ç´¢](ç­”ãˆã§äºŒåˆ†æ¢ç´¢.md) - [ç­”ãˆãŒåºƒç¾©çŸ­èª¿å¢—åŠ ã«ãªã‚‹ç­”ãˆã§ã®äºŒåˆ†æ¢ç´¢](ç­”ãˆãŒåºƒç¾©çŸ­èª¿å¢—åŠ ã«ãªã‚‹å•é¡Œã®äºŒåˆ†æ¢ç´¢.md) - [ç­”ãˆãŒçŸ­èª¿éæ¸›å°‘ã«ãªã‚‹ç­”ãˆã§ã®äºŒåˆ†æ¢ç´¢](ç­”ãˆãŒçŸ­èª¿éæ¸›å°‘ã«ãªã‚‹å•é¡Œã®äºŒåˆ†æ¢ç´¢.md) - [ç­”ãˆã§ lower_bound](ç­”ãˆã§lower_bound.md) - [ç­”ãˆã§ upper_bound](ç­”ãˆã§upper_bound.md)  ---  ## æ–‡å­—åˆ—  - [RLEï¼ˆãƒ©ãƒ³ãƒ¬ãƒ³ã‚°ã‚¹åœ§ç¸®ï¼‰](RLE.md) - [string éƒ¨åˆ†ä¸€è‡´](stringéƒ¨åˆ†ä¸€è‡´.md)  ---  ## æ•°å­¦ãƒ»æ•°åˆ—  - [æ•°å­¦ã¾ã¨ã‚](æ•°å­¦ã¾ã¨ã‚.md) - [æ•°åˆ—](æ•°åˆ—.md) - [Né€²æ•°å¤‰æ›](Né€²æ•°å¤‰æ›.md) - [æ•°å­—æ¡æ•°](æ•°å­—æ¡æ•°.md) - [åº§æ¨™åœ§ç¸®](åº§æ¨™åœ§ç¸®.md) - [ç´ æ•°ã¾ã¨ã‚](ç´ æ•°ã¾ã¨ã‚.md) - [ã‚¨ãƒ©ãƒˆã‚¹ãƒ†ãƒã‚¹ã®ç¯©](ã‚¨ãƒ©ãƒˆã‚¹ãƒ†ãƒã‚¹ã®ç¯©.md) - [ç´ å› æ•°åˆ†è§£ vi](ç´ å› æ•°åˆ†è§£vi.md) - [ç´ å› æ•°åˆ†è§£ pi](ç´ å› æ•°åˆ†è§£pi.md) - [æœ€é•·å¢—åŠ éƒ¨åˆ†åˆ—](æœ€é•·å¢—åŠ éƒ¨åˆ†åˆ—.md) - [åˆ†æ•°](åˆ†æ•°.md) - [è»¢å€’æ•°](è»¢å€’æ•°.md)  ---  ## ã‚°ãƒ©ãƒ•  - [ã‚°ãƒ©ãƒ•ã¾ã¨ã‚](ã‚°ãƒ©ãƒ•ã¾ã¨ã‚.md) - [å¼·é€£çµæˆåˆ†åˆ†è§£](å¼·é€£çµæˆåˆ†åˆ†è§£.md) - [æœ¨ç›´å¾„](æœ¨ç›´å¾„.md) - [ãƒ¯ãƒ¼ã‚·ãƒ£ãƒ«ãƒ•ãƒ­ã‚¤ãƒ‰](ãƒ¯ãƒ¼ã‚·ãƒ£ãƒ«ãƒ•ãƒ­ã‚¤ãƒ‰.md) - [ãƒ€ã‚¤ã‚¯ã‚¹ãƒˆãƒ©](ãƒ€ã‚¤ã‚¯ã‚¹ãƒˆãƒ©.md) - [æœ€å°å…¨åŸŸæœ¨](æœ€å°å…¨åŸŸæœ¨.md)  ---  ## ãƒ•ãƒ­ãƒ¼ãƒ»ãƒãƒƒãƒãƒ³ã‚°  - [æœ€å¤§ãƒ•ãƒ­ãƒ¼](æœ€å¤§ãƒ•ãƒ­ãƒ¼.md) - [ãƒ•ãƒ­ãƒ¼ã¾ã¨ã‚](ãƒ•ãƒ­ãƒ¼ã¾ã¨ã‚.md) - [äºŒéƒ¨ãƒãƒƒãƒãƒ³ã‚°](äºŒéƒ¨ãƒãƒƒãƒãƒ³ã‚°.md) - [ãƒ€ãƒ–ãƒªãƒ³ã‚°](ãƒ€ãƒ–ãƒªãƒ³ã‚°.md) ---  ## DPãƒ»å…¸å‹  - [ãƒŠãƒƒãƒ—ã‚¶ãƒƒã‚¯](ãƒŠãƒƒãƒ—ã‚¶ãƒƒã‚¯.md) - [æœ€é•·å¢—åŠ éƒ¨åˆ†åˆ—](æœ€é•·å¢—åŠ éƒ¨åˆ†åˆ—.md) - [ãã®ä»–å…¸å‹](ãã®ä»–å…¸å‹.md) - - [ãƒ€ãƒ–ãƒªãƒ³ã‚°](ãƒ€ãƒ–ãƒªãƒ³ã‚°.md)   "
  },
  {
    "title": "ä¸­å¤®å€¤",
    "url": "ä¸­å¤®å€¤.html",
    "content": "# ä¸­å¤®å€¤  chu(v) ã§vã®ä¸­å¤®å€¤ãŒæ±‚ã‚ã‚‰ã‚Œã‚‹  ä¸­å¤®å€¤ã¯å°æ•°ã«ãªã‚‹ã“ã¨ã‚‚ã‚ã‚‹ã“ã¨ã«æ³¨æ„  ```cpp  template<typename T>  double chu(vector<T> v){     int n = v.size();     sort(v.begin(),v.end());     if(n%2==0){         return (double)(v[n/2-1]+v[n/2])/(double)2;     }     else{         return (double)v[n/2];     } }  ``` "
  },
  {
    "title": "äºŒåˆ†æ¢ç´¢",
    "url": "äºŒåˆ†æ¢ç´¢.html",
    "content": "# äºŒåˆ†æ¢ç´¢  - [boolã®ç­”ãˆã§äºŒåˆ†æ¢ç´¢](ç­”ãˆã§äºŒåˆ†æ¢ç´¢.md) - [ç­”ãˆã§lower_bound](ç­”ãˆã§lower_bound.md) - [ç­”ãˆã§upper_bound](ç­”ãˆã§upper_bound.md) - [åºƒç¾©çŸ­èª¿å¢—åŠ ã¨ãªã‚‹ç­”ãˆã§ç‰¹å®šã®å€¤ã®ç¯„å›²ã‚’æ±‚ã‚ã‚‹](ç­”ãˆãŒåºƒç¾©çŸ­èª¿å¢—åŠ ã«ãªã‚‹å•é¡Œã®äºŒåˆ†æ¢ç´¢.md) - [çŸ­èª¿éå¢—åŠ ã¨ãªã‚‹ç­”ãˆã§ç‰¹å®šã®å€¤ã®ç¯„å›²ã‚’æ±‚ã‚ã‚‹](ç­”ãˆãŒçŸ­èª¿éæ¸›å°‘ã«ãªã‚‹å•é¡Œã®äºŒåˆ†æ¢ç´¢.md) - [äºŒåˆ†æ¢ç´¢ç”¨vector](äºŒåˆ†æ¢ç´¢ç”¨vector.md) "
  },
  {
    "title": "äºŒåˆ†æ¢ç´¢ç”¨vector",
    "url": "äºŒåˆ†æ¢ç´¢ç”¨vector.html",
    "content": "# äºŒåˆ†æ¢ç´¢ç”¨vector  ä½¿ã„æ–¹ã¯æ™®é€šã®vectorã¨åŒã˜  lb = lower_bound  up = upperbound  ika = ä»¥ä¸‹  mim = æœªæº€  çµæœãŒã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã§ã¯ãªãæ·»å­—ã§å¸°ã£ã¦ãã‚‹  end() ã«ç›¸å½“ã™ã‚‹ãƒªã‚¿ãƒ¼ãƒ³ã¯-1  X ~ Yã€€ã®é–“ã«ã‚ã‚‹å€‹æ•°ã‚’æ•°ãˆãŸã„ã¨ãã¯ ub(Y) - lb(X)  ```cpp  class bs{     public :      vector<long long> v;     bs(long long n,long long x){         v.assign(n,x);         return;     }     void sort(){         std::sort(v.begin(),v.end());     }     long long& at(long long pos){         return v[pos];     }     long long& operator[](long long pos){         return v[pos];     }     const long long& operator[](long long pos) const{         return v[pos];     }     void push_back(long long x){         v.push_back(x);     }     void pop_back(){         v.pop_back();     }     long long lb(long long x){         auto it = lower_bound(v.begin(),v.end(),x);         if(it == v.end()){             return -1;         }         else{             return it - v.begin();         }     }     long long ub(long long x){         auto it = upper_bound(v.begin(),v.end(),x);         if(it == v.end()){             return -1;         }         else{             return it - v.begin();         }     }     long long mim(long long x){         auto it = lower_bound(v.begin(),v.end(),x);         if(it == v.begin()){             return -1;         }         else{             --it;             return it - v.begin();         }     }     long long ika(long long x){         auto it = upper_bound(v.begin(),v.end(),x);         if(it == v.begin()){             return -1;         }         else{             --it;             return it - v.begin();         }            }     long long cnt_ika(long long x){         return ika(x)+1;     }     long long cnt_mim(long long x){         return mim(x)+1;     }     long long cnt_lb(long long x){         if(lb(x) == -1){             return 0;         }         return v.size() - lb(x);     }     long long cnt_ub(long long x){         if(ub(x)==-1){             return 0;         }         return v.size() - ub(x);     } };  ``` "
  },
  {
    "title": "äºŒæ¬¡å…ƒç´¯ç©å’Œ",
    "url": "äºŒæ¬¡å…ƒç´¯ç©å’Œ.html",
    "content": "# äºŒæ¬¡å…ƒç´¯ç©å’Œ  rui2D R(v) ã§vã®äºŒæ¬¡å…ƒç´¯ç©å’Œã‚’ä½œã‚‹  R.query(a,b,c,d)ã§  ``` (a,b)(   )(   ) (   )(   )(   ) (   )(   )(c,d)   ``` ã®åŒºé–“ã®ç´¯ç©ã‚’å–ã‚‹  ```cpp class rui2D{     public :      vector<vector<int>> v;     rui2D(vector<vector<int>>& a){         v = a;         int h = v.size();         int w = v[0].size();         for(int i = 0;i < h;i++){             for(int j = 1;j < w;j++){                 v[i][j] += v[i][j-1];             }         }         for(int j = 0;j < w;j++){             for(int i = 1;i < h;i++){                 v[i][j] += v[i-1][j];             }         }     }     int query(int a,int b,int c,int d){         int ans = v[c][d];         if(a!=0)ans -= v[a-1][d];         if(b!=0)ans -= v[c][b-1];         if(a!=0 && b != 0)ans += v[a-1][b-1];         return ans;     } }; ``` "
  },
  {
    "title": "äºŒéƒ¨ãƒãƒƒãƒãƒ³ã‚°",
    "url": "äºŒéƒ¨ãƒãƒƒãƒãƒ³ã‚°.html",
    "content": "# äºŒéƒ¨ãƒãƒƒãƒãƒ³ã‚°   AIã«æ›¸ã‹ã›ã¾ã—ãŸ ã¾ãŸä»Šåº¦ã¡ã‚ƒã‚“ã¨æ›¸ãã¾ã™  ```cpp class bipartite_matching{ public:     int nL,nR;     vector<vector<int>> g;     vector<int> dist;     vector<int> matchL,matchR;      bipartite_matching(int L,int R){         nL = L;         nR = R;         g.resize(nL);         matchL.assign(nL,-1);         matchR.assign(nR,-1);         dist.resize(nL);     }      void add_edge(int l,int r){         // l : 0..nL-1, r : 0..nR-1         g[l].push_back(r);     }      bool bfs(){         queue<int> q;         for(int i = 0;i < nL;i++){             if(matchL[i] == -1){                 dist[i] = 0;                 q.push(i);             }             else{                 dist[i] = -1;             }         }          bool reachable = false;          while(!q.empty()){             int v = q.front();             q.pop();             for(int to : g[v]){                 int u = matchR[to];                 if(u >= 0){                     if(dist[u] < 0){                         dist[u] = dist[v] + 1;                         q.push(u);                     }                 }                 else{                     reachable = true;                 }             }         }         return reachable;     }      bool dfs(int v){         for(int to : g[v]){             int u = matchR[to];             if(u < 0 || (u >= 0 && dist[u] == dist[v] + 1 && dfs(u))){                 matchL[v] = to;                 matchR[to] = v;                 return true;             }         }         dist[v] = -1;         return false;     }      int max_matching(){         int res = 0;         while(bfs()){             for(int i = 0;i < nL;i++){                 if(matchL[i] == -1){                     if(dfs(i)){                         res++;                     }                 }             }         }         return res;     } };  ``` "
  },
  {
    "title": "ä¾¿åˆ©ãªã‚„ã¤",
    "url": "ä¾¿åˆ©ãªã‚„ã¤.html",
    "content": "# ä¾¿åˆ©ãªã‚„ã¤  - [stringéƒ¨åˆ†ä¸€è‡´ç¢ºèª](stringéƒ¨åˆ†ä¸€è‡´.md) "
  },
  {
    "title": "åˆ†æ•°",
    "url": "åˆ†æ•°.html",
    "content": "# åˆ†æ•°  åˆ†æ•°ã‚’æ‰±ãˆã‚‹æ§‹é€ ä½“  ``` + - * / ãŒã§ãã‚‹ ``` ã‚ã¾ã‚Šå¤§ããã—ã™ãã‚‹ã¨å£Šã‚Œã‚‹  ## åˆæœŸåŒ–  ft x = {3,4}  // ï¼”åˆ†ã®ï¼“    ```cpp  class ft{     public :     long long si = 0;     long long bo = 1;     ft(long long x=0,long long y=1){         si = x;         bo = y;         yaku();     }     void yaku(){         long long w = gcd(abs(si), abs(bo));         si /= w;         bo /= w;         if (bo < 0) si = -si, bo = -bo;     }     ft operator+(const ft& x) const {         if(bo == x.bo){             return ft(                 si+x.si,                 bo             );         }         ft ret(             si*x.bo + x.si*bo,             bo * x.bo                     );         return ret;     }     ft operator-(const ft& x) const {         if(bo == x.bo){             return ft(                 si-x.si,                 bo             );         }         ft ret(             si*x.bo - x.si*bo,             bo * x.bo                     );          return ret;     }     ft operator*(const ft& x) const {         ft ret(             si * x.si,             bo * x.bo         );           return ret;          }     ft operator/(const ft& x) const {         ft ret(             si * x.bo,             bo * x.si         );          return ret;     } };   ``` "
  },
  {
    "title": "åŒºé–“æœ€å¤§ä»£å…¥é…å»¶ã‚»ã‚°æœ¨",
    "url": "åŒºé–“æœ€å¤§ä»£å…¥é…å»¶ã‚»ã‚°æœ¨.html",
    "content": "# åŒºé–“æœ€å¤§åŒºé–“ä»£å…¥é…å»¶ã‚»ã‚°æœ¨  ```cpp class lst{     public :      const int inf = 1e9;     vector<int> seg,lazy;     int siz = 1;     vector<bool> d;     lst(int n,int x){         while(siz < n){             siz *= 2;         }         seg.assign(siz*2,x);         lazy.assign(siz*2,0);         d.assign(siz*2,false);     }     void push(int pos){         if(!d[pos])return;         seg[pos] = lazy[pos];         d[pos] = false;         if(pos < siz){             lazy[pos*2] = seg[pos];             lazy[pos*2+1] = seg[pos];             d[pos*2] = true;             d[pos*2+1] = true;         }     }     void range_assign(int l,int r,int x){         range_assign(l,r,x,1,0,siz);     }     int range_max(int l,int r){         return range_max(l,r,1,0,siz);     }     private :     void range_assign(int l,int r,int x,int pos,int a,int b){         push(pos);         if (r <= a || b <= l) return;         if(l <= a && b <= r){             seg[pos] = x;             lazy[pos] = x;             d[pos] = true;             return;         }          int mid = (a+b)/2;         range_assign(l,r,x,pos*2,a,mid);         range_assign(l,r,x,pos*2+1,mid,b);         seg[pos] = max(seg[pos*2],seg[pos*2+1]);     }     int range_max(int l,int r,int pos,int a,int b){         push(pos);         if(r <= a || b <= l) return -inf;         if(l <= a && b <= r){             return seg[pos];         }         int mid = (a+b)/2;         return max(             range_max(l,r,pos*2,a,mid),             range_max(l,r,pos*2+1,mid,b)         );     } };  ``` "
  },
  {
    "title": "åŒºé–“æœ€å°ä»£å…¥é…å»¶ã‚»ã‚°æœ¨",
    "url": "åŒºé–“æœ€å°ä»£å…¥é…å»¶ã‚»ã‚°æœ¨.html",
    "content": "# åŒºé–“æœ€å°åŒºé–“ä»£å…¥é…å»¶ã‚»ã‚°æœ¨  ```cpp class lst{     public :      const int inf = 1e9;     vector<int> seg,lazy;     int siz = 1;     vector<bool> d;     lst(int n,int x){         while(siz < n){             siz *= 2;         }         seg.assign(siz*2,x);         lazy.assign(siz*2,0);         d.assign(siz*2,false);     }     void push(int pos){         if(!d[pos])return;         seg[pos] = lazy[pos];         d[pos] = false;         if(pos < siz){             lazy[pos*2] = seg[pos];             lazy[pos*2+1] = seg[pos];             d[pos*2] = true;             d[pos*2+1] = true;         }     }     void range_assign(int l,int r,int x){         range_assign(l,r,x,1,0,siz);     }     int range_min(int l,int r){         return range_min(l,r,1,0,siz);     }     private :     void range_assign(int l,int r,int x,int pos,int a,int b){         push(pos);         if (r <= a || b <= l) return;         if(l <= a && b <= r){             seg[pos] = x;             lazy[pos] = x;             d[pos] = true;             return;         }          int mid = (a+b)/2;         range_assign(l,r,x,pos*2,a,mid);         range_assign(l,r,x,pos*2+1,mid,b);         seg[pos] = min(seg[pos*2],seg[pos*2+1]);     }     int range_min(int l,int r,int pos,int a,int b){         push(pos);         if(r <= a || b <= l) return inf;         if(l <= a && b <= r){             return seg[pos];         }         int mid = (a+b)/2;         return min(             range_min(l,r,pos*2,a,mid),             range_min(l,r,pos*2+1,mid,b)         );     } };  ``` "
  },
  {
    "title": "åº§æ¨™åœ§ç¸®",
    "url": "åº§æ¨™åœ§ç¸®.html",
    "content": "# åº§æ¨™åœ§ç¸®  çµæœã‚’å…¥ã‚Œã‚‹mapã€é€†ã®å¾©å…ƒç”¨ã®vectorã€åœ§ç¸®ã—ãŸã„vectorã€€ã‚’å…¥ã‚Œã‚‹  mapã«åœ§ç¸®å‰ã®åº§ç¤ã‚’å…¥ã‚Œã‚‹ã¨åœ§ç¸®å¾Œã®åº§æ¨™ãŒå¸°ã£ã¦ãã‚‹  vectorã«åœ§ç¸®å¾Œã®åº§æ¨™ã‚’å…¥ã‚Œã‚‹ã¨åœ§ç¸®å‰ã®åº§æ¨™ãŒå¸°ã£ã¦ãã‚‹  ```cpp void ash(map<int,int>& m,vector<int>& g,vector<int> v){     int n = v.size();     m.clear();     sort(v.begin(),v.end());     int j = 0;     for(int i = 0;i < n;i++){         if(m.count(v[i]))continue;         m[v[i]] = j;         while ((int)g.size() <= j) g.push_back(0);         g[j] = v[i];         j++;     }     return ; } ``` "
  },
  {
    "title": "å¼·é€£çµæˆåˆ†åˆ†è§£",
    "url": "å¼·é€£çµæˆåˆ†åˆ†è§£.html",
    "content": "# å¼·é€£çµæˆåˆ†åˆ†è§£  å¼·é€£çµæˆåˆ†ãã‚Œãã‚Œã‚’vectorã«ã¾ã¨ã‚ãŸvviã§returnãŒæ¥ã‚‹  scc( é ‚ç‚¹æ•°ã€€ã€ã€€vviã®å½¢ã®ã‚°ãƒ©ãƒ•ã€€ï¼‰ã€€ã§ã§ãã‚‹  ```cpp vector<vector<int>> scc(int n,const vector<vector<int>>& v){     vector<vector<int>> vv(n);     for(int i = 0;i < n;i++){         for(int j = 0;j < v[i].size();j++){             vv[v[i][j]].push_back(i);         }     }     vector<int> res;     vector<bool> visited(n,false);     function<void(int)> f = [&](int pos){         visited[pos] = true;         for(int i : v[pos]){             if(!visited[i])f(i);         }         res.push_back(pos);     };     for(int i = 0;i < n;i++){         if(!visited[i]){             f(i);         }     }     vector<vector<int>> ans;     visited.assign(n,false);     for(int i = res.size()-1; i >= 0;i--){         if(visited[res[i]])continue;         vector<int> p = {res[i]};         function<void(int)> d = [&](int pos){             visited[pos] = true;             for(int i : vv[pos]){                 if(visited[i])continue;                 p.push_back(i);                 d(i);             }         };         d(res[i]);         ans.push_back(p);     }     return ans; } ``` "
  },
  {
    "title": "æ•°åˆ—",
    "url": "æ•°åˆ—.html",
    "content": "# æ•°åˆ—   - [å¾ªç’°é…åˆ—ã§ã®é•·ã•wã®ç¯„å›²ã®å’Œã®æœ€å¤§å€¤](rmax.md)  - [å¾ªç’°é…åˆ—ã§ã®é•·ã•wã®ç¯„å›²ã®å’Œã®æœ€å°å€¤](rmin.md)  - [æœ€é•·å¢—åŠ éƒ¨åˆ†åˆ—](æœ€é•·å¢—åŠ éƒ¨åˆ†åˆ—.md)  - [ä¸­å¤®å€¤](ä¸­å¤®å€¤.md)  - [è»¢å€’æ•°](è»¢å€’æ•°.md) "
  },
  {
    "title": "æ•°å­—æ¡æ•°",
    "url": "æ•°å­—æ¡æ•°.html",
    "content": "# æ•°å­—æ¡æ•°  ket(x)ã§xã®æ¡æ•°ãŒè¿”ã£ã¦ãã‚‹  ```cpp  int ket(int n){     int ans = 0;     while(n != 0){         ans++;         n /= 10;     }     return ans; }  ``` "
  },
  {
    "title": "æ•°å­¦ã¾ã¨ã‚",
    "url": "æ•°å­¦ã¾ã¨ã‚.html",
    "content": "# æ•°å­¦  - [ç´ æ•°](ç´ æ•°ã¾ã¨ã‚.md) - [Né€²æ•°å¤‰æ›](Né€²æ•°å¤‰æ›.md) - [æ•°å­—æ¡æ•°ã‚«ã‚¦ãƒ³ãƒˆ](æ•°å­—æ¡æ•°.md) - [æ•°åˆ—](æ•°åˆ—.md) - [åˆ†æ•°](åˆ†æ•°.md) "
  },
  {
    "title": "æœ€å¤§ãƒ•ãƒ­ãƒ¼",
    "url": "æœ€å¤§ãƒ•ãƒ­ãƒ¼.html",
    "content": "# æœ€å¤§ãƒ•ãƒ­ãƒ¼  add(u,v,f)  u ~ v ã«capãŒfã®è¾ºã‚’è¿½åŠ ã—ã¦  flow(s,t) ã§çµæœãŒå‡ºã¦ãã‚‹   ```cpp class din{      struct edge{         int to;         int cap;         int rev;     };      public :      int n;     vector<vector<edge>> g;     vector<int> level;     vector<int> ite;      din(int x){         n = x;         g.resize(n);         level.resize(n);         ite.resize(n);     }      void add(int from,int to,int cap){         g[from].push_back(edge{to,cap,(int)g[to].size()});         g[to].push_back(edge{from,0,(int)g[from].size()-1});     }      bool bfs(int s,int t){         level.assign(n,-1);         queue<int> q;         q.push(s);         level[s] = 0;         while(q.size()!=0){             int pos = q.front();             q.pop();             for(const edge& e : g[pos]){                 if(e.cap > 0 && level[e.to] < 0){                     level[e.to] = level[pos]+1;                     q.push(e.to);                 }             }         }         return level[t] >= 0;     }     int dfs(int v,int t,int f){         if(v==t)return f;         for(int &i = ite[v];i < (int)g[v].size();i++){             edge& e = g[v][i];             if(e.cap > 0 && level[v] < level[e.to]){                 int d = dfs(e.to,t,min(f,e.cap));                 if(d > 0){                     e.cap -= d;                     g[e.to][e.rev].cap += d;                     return d;                 }             }         }         return 0;     }     int flow(int s,int t){         int ans = 0;         while(1){             if(!bfs(s,t))break;             ite.assign(n,0);             int f = dfs(s,t,INF);             while(1){                 if(f>0){                     ans += f;                     f = dfs(s,t,INF);                 }                 else{                     break;                 }             }                      }         return ans;     }  };  ``` # è¾ºã‚’å¾©å…ƒã—ãŸã„   ```cpp  class din{      struct edge{         int to;         int cap;         int rev;     };      public :      int n;     vector<vector<edge>> g;     vector<int> level;     vector<int> ite;      din(int x){         n = x;         g.resize(n);         level.resize(n);         ite.resize(n);     }      void add(int from,int to,int cap){         g[from].push_back(edge{to,cap,(int)g[to].size()});         g[to].push_back(edge{from,0,(int)g[from].size()-1});     }      bool bfs(int s,int t){         level.assign(n,-1);         queue<int> q;         q.push(s);         level[s] = 0;         while(q.size()!=0){             int pos = q.front();             q.pop();             for(const edge& e : g[pos]){                 if(e.cap > 0 && level[e.to] < 0){                     level[e.to] = level[pos]+1;                     q.push(e.to);                 }             }         }         return level[t] >= 0;     }     int dfs(int v,int t,int f){         if(v==t)return f;         for(int &i = ite[v];i < (int)g[v].size();i++){             edge& e = g[v][i];             if(e.cap > 0 && level[v] < level[e.to]){                 int d = dfs(e.to,t,min(f,e.cap));                 if(d > 0){                     e.cap -= d;                     g[e.to][e.rev].cap += d;                     return d;                 }             }         }         return 0;     }     int flow(int s,int t,vector<pair<int,int>>& res){         int ans = 0;         while(1){             if(!bfs(s,t))break;             ite.assign(n,0);             int f = dfs(s,t,INF);             while(1){                 if(f>0){                     ans += f;                     f = dfs(s,t,INF);                 }                 else{                     break;                 }             }                     }         rep(i,n){             for(edge& e : g[i]){                 if(e.to==s || e.to==t)continue;                 if(e.cap==0){                     res.push_back({i,e.to});                 }             }         }         return ans;     }     int flow(int s,int t){         int ans = 0;         while(1){             if(!bfs(s,t))break;             ite.assign(n,0);             int f = dfs(s,t,INF);             while(1){                 if(f>0){                     ans += f;                     f = dfs(s,t,INF);                 }                 else{                     break;                 }             }                     }         return ans;     } };   ``` "
  },
  {
    "title": "æœ€å°å…¨åŸŸæœ¨",
    "url": "æœ€å°å…¨åŸŸæœ¨.html",
    "content": "# ç„¡å‘ã‚°ãƒ©ãƒ•ã®æœ€å°å…¨åŸŸæœ¨   vector<vector<pair<int,int>>> ã®çŠ¶æ…‹ã®ã‚°ãƒ©ãƒ•ã‚’å…¥ã‚Œã‚‹  æœ€å°å…¨åŸŸæœ¨ã®ã‚³ã‚¹ãƒˆãŒè¿”ã£ã¦ãã‚‹  éé€£çµã®å ´åˆã¯-1ãŒè¿”ã£ã¦ãã‚‹   ```cpp  long long cost(vector<vector<pair<long long,long long>>>& v){     long long n = v.size();     long long ans = 0;     dsu d(n);     priority_queue<pair<long long,pair<long long,long long>>,vector<pair<long long,pair<long long,long long>>>,greater<pair<long long,pair<long long,long long>>>> q;     rep(i,n)for(pair<long long,long long> p : v[i]){         if(p.first > i){             q.push({p.second,{i,p.first}});         }     }     while(q.size()!=0){         long long w = q.top().first;         long long x = q.top().second.first;         long long y = q.top().second.second;         q.pop();         if(!d.same(x,y)){             ans += w;             d.merge(x,y);         }     }     if(d.size(0)!=n)return -1;     return ans; }  ```   # æœ€å°å…¨åŸŸæœ¨ã®å†…å®¹ãŒæ¬²ã—ã„å ´åˆ  ```cpp  vector<pair<long long,long long>>  cost(vector<vector<pair<long long,long long>>>& v){     long long n = v.size();     vector<pair<long long,long long>> ans;     dsu d(n);     priority_queue<pair<long long,pair<long long,long long>>,vector<pair<long long,pair<long long,long long>>>,greater<pair<long long,pair<long long,long long>>>> q;     rep(i,n)for(pair<long long,long long> p : v[i]){         if(p.first > i){             q.push({p.second,{i,p.first}});         }     }     while(q.size()!=0){         long long w = q.top().first;         long long x = q.top().second.first;         long long y = q.top().second.second;         q.pop();         if(!d.same(x,y)){             d.merge(x,y);             ans.push_back({x,y});         }     }     if(d.size(0)!=n)return {{-1,-1}};     return ans; }  ``` "
  },
  {
    "title": "æœ€é•·å¢—åŠ éƒ¨åˆ†åˆ—",
    "url": "æœ€é•·å¢—åŠ éƒ¨åˆ†åˆ—.html",
    "content": "# æœ€é•·å¢—åŠ éƒ¨åˆ†åˆ—  lis_sizeã§æœ€é•·éƒ¨åˆ†å¢—åŠ åˆ—ã®é•·ã•  los_posã§ãã‚Œãã‚Œã®ä½ç½®ã¾ã§ã®æœ€é•·å¢—åŠ éƒ¨åˆ†åˆ—ã®é•·ã•ãŒè¨˜éŒ²ã•ã‚ŒãŸvectorãŒå¸°ã£ã£ã¦ãã‚‹  ```cpp      int lis_size(vector<int> v){         vector<int> dp;         int n = v.size();         for(int i : v){                             auto it = lower_bound(dp.begin(),dp.end(),i);             if(it == dp.end())dp.push_back(i);             else *it = i;         }         return dp.size();     }     vector<int> lis_pos(vector<int> v){         vector<int> dp;         int n = v.size();         vector<int> ans(n);         for(int j = 0;j < n;j++){             int i = v[j];             auto it = lower_bound(dp.begin(),dp.end(),i);             if(it == dp.end()){                 dp.push_back(i);                 ans[j] = dp.size();             }             else{                 *it = i;                 ans[j] = (it - dp.begin())+1;             }         }         return ans;     }  ``` "
  },
  {
    "title": "æœ¨ç›´å¾„",
    "url": "æœ¨ç›´å¾„.html",
    "content": "# æœ¨ã®ç›´å¾„ã‚’æ±‚ã‚ã‚‹  cho(vvi) vviã®ã‚°ãƒ©ãƒ•ã‚’å…¥ã‚Œã‚‹  æœ¨ã®ç›´å¾„ãŒè¿”ã£ã¦ãã‚‹    ```cpp int cho(vector<vector<int>>& v){     int n = v.size();     vector<int> go(n,-1);     queue<int> q;     q.push(0);     go[0] = 0;     while(q.size()!=0){         int pos = q.front();         q.pop();         for(int i : v[pos]){             if(go[i] == -1){                 go[i] = go[pos]+1;                 q.push(i);             }         }     }     int st = max_element(go.begin(),go.end())-go.begin();     q.push(st);     go.assign(n,-1);     go[st] = 0;     while(q.size()!=0){         int pos = q.front();         q.pop();         for(int i : v[pos]){             if(go[i] == -1){                 go[i] = go[pos]+1;                 q.push(i);             }         }     }     return *max_element(go.begin(),go.end()); } ```  # ç›´å¾„ã«ãªã‚‹ãƒšã‚¢ãŒçŸ¥ã‚ŠãŸã„å ´åˆ  ```cpp  pair<int,int> cho(vector<vector<int>>& v){     int n = v.size();     vector<int> go(n,-1);     queue<int> q;     q.push(0);     go[0] = 0;     while(q.size()!=0){         int pos = q.front();         q.pop();         for(int i : v[pos]){             if(go[i] == -1){                 go[i] = go[pos]+1;                 q.push(i);             }         }     }     int st = max_element(go.begin(),go.end())-go.begin();     q.push(st);     go.assign(n,-1);     go[st] = 0;     while(q.size()!=0){         int pos = q.front();         q.pop();         for(int i : v[pos]){             if(go[i] == -1){                 go[i] = go[pos]+1;                 q.push(i);             }         }     }     return {st,max_element(go.begin(),go.end()) - go.begin()}; }  ```  "
  },
  {
    "title": "ç­”ãˆãŒåºƒç¾©çŸ­èª¿å¢—åŠ ã«ãªã‚‹å•é¡Œã®äºŒåˆ†æ¢ç´¢",
    "url": "ç­”ãˆãŒåºƒç¾©çŸ­èª¿å¢—åŠ ã«ãªã‚‹å•é¡Œã®äºŒåˆ†æ¢ç´¢.html",
    "content": "# ç­”ãˆãŒåºƒç¾©çŸ­èª¿å¢—åŠ ã¨ãªã‚‹å•é¡Œã§ã®ç‰¹å®šã®å€¤ã®ç¯„å›²ã‚’æ±‚ã‚ã‚‹äºŒåˆ†æ¢ç´¢   int test(mid)  ã§mid ã®æ™‚ã®å€¤ã‚’è¿”ã™é–¢æ•°ã‚’ä½œã£ã¦ãŠãå¿…è¦ãŒã‚ã‚‹  bs(k) = ç­”ãˆãŒkã¨ãªã‚‹ç¯„å›²ã‚’{L,R}ã®pairã§è¿”ã™  ```cpp  pair<int,int> bs(int k){     int big,small;     int l = 0;     int r = INF;     while(l+1 < r){    // find big         int mid = (l+r)/2;         int res = test(mid);         if(res > k) r = mid;         else l = mid;     }     big = l;     l = 0;     r = INF;     while(l+1 < r){    // find small         int mid = (l+r)/2;         int res = test(mid);         if(res >= k)r = mid;         else l = mid;     }         small = r;     if(small > big) return {-1, -1};     return {small,big}; }  ``` "
  },
  {
    "title": "ç­”ãˆãŒçŸ­èª¿éæ¸›å°‘ã«ãªã‚‹å•é¡Œã®äºŒåˆ†æ¢ç´¢",
    "url": "ç­”ãˆãŒçŸ­èª¿éæ¸›å°‘ã«ãªã‚‹å•é¡Œã®äºŒåˆ†æ¢ç´¢.html",
    "content": "# çŸ­èª¿éå¢—åŠ ã®ç­”ãˆã§ã®å€¤Kã®ç¯„å›²   int test(mid) ã®é–¢æ•°ã‚’ã‚ã‚‰ã‹ã˜ã‚ä½œã£ã¦ãŠãå¿…è¦ãŒã‚ã‚‹  bs(k) = ç­”ãˆãŒkã«ãªã‚‹ç¯„å›²ã®{L,R}ã‚’pairã§è¿”ã™  ```cpp  pair<int,int> bs(int k){      int big,small;     int l = 0;     int r = INF;     while(l+1 < r){    // find big         int mid = (l+r)/2;         int res = test(mid);         if(res >= k){             l = mid;         }         else{             r = mid;         }     }     big = l;     l = 0;     r = INF;     while(l+1 < r){    // find small         int mid = (l+r)/2;         int res = test(mid);         if(res > k){             l = mid;         }         else{             r = mid;         }     }         small = r;     return {small,big}; }  ``` "
  },
  {
    "title": "ç­”ãˆã§lower_bound",
    "url": "ç­”ãˆã§lower_bound.html",
    "content": "# ç­”ãˆã§lower_bound   intã‚’è¿”ã™test()ã‚’ä½œã£ã¦ãŠãå¿…è¦ãŒã‚ã‚‹  ```cpp  int bs(int x){     // xã«ã¤ã„ã¦lower_bound     int l = -1;     int r = INF;     while(l+1 < r){         int mid = (l+r)/2;         if(test(mid) >= x)r = mid;         else l = mid;     }     return r; }  ``` "
  },
  {
    "title": "ç­”ãˆã§upper_bound",
    "url": "ç­”ãˆã§upper_bound.html",
    "content": "# ç­”ãˆã§upper_bound   intã‚’è¿”ã™test()ã‚’ä½œã£ã¦ãŠãå¿…è¦ãŒã‚ã‚‹  ```cpp  int bs(int x){     // xã«ã¤ã„ã¦upper_bound     int l = -1;     int r = INF;     while(l+1 < r){         int mid = (l+r)/2;         if(test(mid) > x)r = mid;         else l = mid;     }     return r; }  ``` "
  },
  {
    "title": "ç­”ãˆã§äºŒåˆ†æ¢ç´¢",
    "url": "ç­”ãˆã§äºŒåˆ†æ¢ç´¢.html",
    "content": "# ç­”ãˆã§äºŒåˆ†æ¢ç´¢  boolã‚’è¿”ã™testã¨ã„ã†é–¢æ•°ã«midã‚’å…¥ã‚Œã‚Œã°ä½¿ãˆã‚‹çŠ¶æ…‹ã«ã—ã¦ãŠãå¿…è¦ãŒã‚ã‚‹    # ç­”ãˆã®æœ€å°åŒ–  true true **true** false false   ã“ã®trueã¨ãªã‚‹æ™‚ã®å€¤ã‚’è¿”ã™  ```cpp  int bs_min(){     long long l = 0;     long long r = 1e18;     while (r - l > 1) {         long long mid = (l + r) / 2;         if (test(mid)) {             r = mid;              } else {             l = mid;              }     }     return r; }  ```   "
  },
  {
    "title": "ç´ å› æ•°åˆ†è§£pi",
    "url": "ç´ å› æ•°åˆ†è§£pi.html",
    "content": "# ç´ å› æ•°åˆ†è§£ã€€pair int,int   ```cpp vector<pair<int,int>>  p(int n){     vector<pair<int,int>> ans;     int x = n;     int k = 0;     while(x % 2 == 0){         k++;         x /= 2;     }     if(k != 0){         ans.push_back({2,k});     }     for(int i = 3;i * i <= n;i+=2){         int cnt = 0;         while(x % i == 0){             cnt++;             x /= i;         }         if(cnt != 0){             ans.push_back({i,cnt});         }         if(x == 1){             break;         }     }     if(x!=1)ans.push_back({x,1});     return ans; }; ``` "
  },
  {
    "title": "ç´ å› æ•°åˆ†è§£vi",
    "url": "ç´ å› æ•°åˆ†è§£vi.html",
    "content": "# ç´ å› æ•°åˆ†è§£ vector int   ```cpp  vector<int> p(int n){     vector<int> ans;     int x = n;     while(x % 2 == 0){         x /= 2;         ans.push_back(2);     }     for(int i = 3;i * i <= n;i+=2){         while(x % i == 0){             x /= i;             ans.push_back(i);         }         if(x == 1){             break;         }     }     if(x!=1)ans.push_back(x);     return ans; };  ``` "
  },
  {
    "title": "ç´ æ•°ã¾ã¨ã‚",
    "url": "ç´ æ•°ã¾ã¨ã‚.html",
    "content": "# ç´ æ•°ã®ã‚ã‚Œã“ã‚Œ  - [ç´ å› æ•°åˆ†è§£vi](ç´ å› æ•°åˆ†è§£vi.md) - [ç´ å› æ•°åˆ†è§£pi](ç´ å› æ•°åˆ†è§£pi.md) - [ç´ æ•°åˆ—æŒ™](ã‚¨ãƒ©ãƒˆã‚¹ãƒ†ãƒã‚¹ã®ç¯©.md) -  "
  },
  {
    "title": "ç´¯ç©å’Œ",
    "url": "ç´¯ç©å’Œ.html",
    "content": "# ç´¯ç©å’Œã‚’ã‚„ã‚‹ãŸã‚ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒª   rui R(v)ã§vã‚’ç´¯ç©å’Œã«ã—ãŸRã‚’ä½œã‚Œã‚‹  queryã§(l,r)ã®ç¯„å›²ã®å’Œã‚’æ±‚ã‚ã‚‰ã‚Œã‚‹   ```cpp template<typename T> class rui{     public:     vector<T> v;     rui(const vector<T>& a){         v = a;         for(int i = 1;i < a.size();i++){             v[i] += v[i-1];         }     }     T query(int l,int r){         if(l == 0){             return v[r];         }         else{             return v[r] - v[l-1];         }     } }; ``` "
  },
  {
    "title": "ç´¯ç©å’Œã¾ã¨ã‚",
    "url": "ç´¯ç©å’Œã¾ã¨ã‚.html",
    "content": "# ç´¯ç©å’Œ  - [ç´¯ç©å’Œ](ç´¯ç©å’Œ.md) - [äºŒæ¬¡å…ƒç´¯ç©å’Œ](äºŒæ¬¡å…ƒç´¯ç©å’Œ.md) - [imos](imos.md) - [imos2D](imos2D.md) "
  },
  {
    "title": "è»¢å€’æ•°",
    "url": "è»¢å€’æ•°.html",
    "content": "# è»¢å€’æ•°  ten(v)ã«å…¥ã‚ŒãŸã‚‰å‹æ‰‹ã«åº§æ¨™åœ§ç¸®ã•ã‚Œã¦è»¢å€’æ•°ãŒå¸°ã£ã¦ãã‚‹  ã‚»ã‚°æœ¨ãŒä¸€ç·’ã«ã¤ã„ã¦ãã¦ã‚‹ã®ã§ã‚»ã‚°æœ¨ã‚’åˆ¥ã§å®šç¾©ã—ã¦ã‚‹å ´åˆã¯æ°—ã‚’ä»˜ã‘ã‚‹   ```cpp  class st{ public:     long long siz = 1;     vector<long long> v;     st (long long n){         siz = 1;         while(siz < n)siz *= 2;         v.assign(2*siz,0);     }     void plus(long long i){         i += siz;         v[i]++;         while(i > 1){             i /= 2;             v[i] = v[i*2]+v[i*2+1];         }     }      long long query(long long L, long long R){   // æ·»å­—ã€L , R         long long ans = 0;         function<void(long long,long long,long long)> f = [&](long long s,long long l,long long r){             if(l >= L && r <= R){                 ans += v[s];                 return;             }             if(r < L || l > R)return;             f(s*2,l,(l+r)/2);             f(s*2+1,(l+r)/2+1,r);             return;         };         f(1,0,siz-1);         return ans;     } }; void ash(map<long long,long long>& m,vector<long long> v){     long long n = v.size();     m.clear();     sort(v.begin(),v.end());     long long j = 0;     for(long long i = 0;i < n;i++){         if(m.count(v[i]))continue;         m[v[i]] = j;         j++;     }     return ; } long long ten(vector<long long> v){     long long n = v.size();     map<long long,long long> m;     ash(m,v);     st seg(m.size());     long long ans = 0;     for(int i = 0;i < n;i++){         ans += seg.query(m[v[i]]+1,m.size()-1);         seg.plus(m[v[i]]);     }     return ans; }  ```  # é€†è»¢å€’æ•°  ```cpp   class st{ public:     long long siz = 1;     vector<long long> v;     st (long long n){         siz = 1;         while(siz < n)siz *= 2;         v.assign(2*siz,0);     }     void plus(long long i){         i += siz;         v[i]++;         while(i > 1){             i /= 2;             v[i] = v[i*2]+v[i*2+1];         }     }      long long query(long long L, long long R){   // æ·»å­—ã€L , R         long long ans = 0;         function<void(long long,long long,long long)> f = [&](long long s,long long l,long long r){             if(l >= L && r <= R){                 ans += v[s];                 return;             }             if(r < L || l > R)return;             f(s*2,l,(l+r)/2);             f(s*2+1,(l+r)/2+1,r);             return;         };         f(1,0,siz-1);         return ans;     } }; void ash(map<long long,long long>& m,vector<long long> v){     long long n = v.size();     m.clear();     sort(v.begin(),v.end());     long long j = 0;     for(long long i = 0;i < n;i++){         if(m.count(v[i]))continue;         m[v[i]] = j;         j++;     }     return ; } long long ten(vector<long long> v){     long long n = v.size();     map<long long,long long> m;     ash(m,v);     st seg(m.size());     long long ans = 0;     for(int i = 0;i < n;i++){         ans += seg.query(m[v[i]]+1,m.size()-1);         seg.plus(m[v[i]]);     }     return ans; }   ``` "
  }
]